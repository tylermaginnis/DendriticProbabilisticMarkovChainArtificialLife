<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Beat Generation Interactive Poetry Machine - Web Edition</title>
    
    <!-- Professional NLP Libraries for Semantic Poetry Processing -->
    <script src="https://unpkg.com/compromise@14.14.4/builds/compromise.js"></script>
    <!-- Synonyms Library - 27,779 words with comprehensive synonym database -->
    <script src="https://unpkg.com/synonyms@1.0.1/dist/synonyms.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gpu.js@latest/dist/gpu-browser.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: linear-gradient(135deg, #0a0a0a, #1a1a2e, #0a0a0a);
            color: #ffffff;
            min-height: 100vh;
            overflow: hidden;
            cursor: none;
            /* Mobile optimizations */
            -webkit-text-size-adjust: 100%;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }
        
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 50;
            pointer-events: none;
            background: 
                repeating-linear-gradient(
                    0deg,
                    transparent,
                    transparent 2px,
                    rgba(0, 255, 136, 0.03) 2px,
                    rgba(0, 255, 136, 0.03) 4px
                );
            animation: crtScanlines 0.1s linear infinite;
        }
        
        body::after {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 51;
            pointer-events: none;
            background: 
                radial-gradient(ellipse at center, transparent 40%, rgba(0, 0, 0, 0.3) 100%),
                linear-gradient(90deg, 
                    transparent 0%, 
                    rgba(0, 255, 136, 0.02) 50%, 
                    transparent 100%
                );
            animation: crtFlicker 0.15s ease-in-out infinite alternate;
        }

        .hypnotic-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: radial-gradient(circle at center, #0a0a1a, #000);
        }

        #dendrite-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        .poetry-overlay {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: 25vh; /* Bottom quarter of screen */
            z-index: 15;
            pointer-events: none;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            background: linear-gradient(to top, rgba(0, 0, 0, 0.8), rgba(0, 0, 0, 0.3), transparent);
            backdrop-filter: blur(5px);
        }

        .poetry-text {
            font-size: 1.7em;
            font-weight: normal;
            text-align: center;
            color: #00ff88;
            text-shadow: 
                0 0 8px rgba(0, 255, 136, 0.8),
                0 0 16px rgba(0, 255, 136, 0.4),
                1px 1px 2px rgba(0, 0, 0, 0.5);
            white-space: normal;
            word-wrap: break-word;
            animation: subtleTextFlow 6s ease-in-out infinite;
            transform-origin: center;
            max-width: 800px;
            line-height: 1.6;
        }
        
        .poetry-text.typing::after {
            content: '|';
            animation: typewriterCursor 1s infinite;
            color: #00ff88;
            text-shadow: 
                0 0 8px rgba(0, 255, 136, 0.8),
                0 0 16px rgba(0, 255, 136, 0.4);
        }
        
        @keyframes typewriterCursor {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }

        @keyframes subtleTextFlow {
            0%, 100% { 
                opacity: 0.8;
                filter: hue-rotate(0deg);
                text-shadow: 
                    0 0 8px rgba(0, 255, 136, 0.8),
                    0 0 16px rgba(0, 255, 136, 0.4);
            }
            25% {
                opacity: 0.9;
                filter: hue-rotate(60deg);
                text-shadow: 
                    0 0 10px rgba(0, 255, 200, 0.9),
                    0 0 20px rgba(0, 255, 200, 0.5);
            }
            50% {
                opacity: 1;
                filter: hue-rotate(120deg);
                text-shadow: 
                    0 0 12px rgba(0, 200, 255, 1),
                    0 0 24px rgba(0, 200, 255, 0.6);
            }
            75% {
                opacity: 0.9;
                filter: hue-rotate(180deg);
                text-shadow: 
                    0 0 10px rgba(100, 255, 200, 0.9),
                    0 0 20px rgba(100, 255, 200, 0.5);
            }
        }
        
        @keyframes crtScanlines {
            0% { transform: translateY(0px); }
            100% { transform: translateY(4px); }
        }
        
        @keyframes crtFlicker {
            0% { opacity: 1; }
            100% { opacity: 0.98; }
        }

        .controls-overlay {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 10;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid rgba(0, 255, 136, 0.3);
            font-size: 12px;
            color: #00ff88;
            backdrop-filter: blur(10px);
            opacity: 0.7;
            transition: opacity 0.3s ease;
        }

        .controls-overlay:hover {
            opacity: 1;
        }

        .status-overlay {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 10;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid rgba(0, 255, 136, 0.3);
            font-size: 12px;
            color: #00ff88;
            backdrop-filter: blur(10px);
            opacity: 0.7;
            font-family: 'Courier New', monospace;
        }

        .audio-visualizer {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 100px;
            z-index: 3;
            pointer-events: none;
        }

        .waveform {
            width: 100%;
            height: 100%;
            background: linear-gradient(to top, rgba(0, 255, 136, 0.1), transparent);
        }

        .hidden {
            display: none;
        }

        /* ============================================================================ */
        /* Mobile Responsive Design */
        /* ============================================================================ */
        
        @media screen and (max-width: 768px) {
            /* Mobile body adjustments */
            body {
                cursor: auto; /* Show cursor on mobile */
                font-size: 14px;
            }
            
            /* Reduce CRT effects on mobile for better performance */
            body::before {
                opacity: 0.5;
                animation: none; /* Disable scanlines animation on mobile */
            }
            
            body::after {
                opacity: 0.3; /* Reduce vignette effect */
            }
            
            /* Mobile-friendly controls */
            .controls-overlay {
                top: 10px;
                left: 10px;
                right: 10px;
                padding: 12px;
                font-size: 14px;
                border-radius: 8px;
                opacity: 0.9;
                max-width: none;
                width: auto;
            }
            
            .controls-overlay:hover {
                opacity: 1;
            }
            
            /* Touch-friendly volume slider */
            .controls-overlay input[type="range"] {
                height: 12px !important;
                min-height: 44px; /* iOS touch target minimum */
                padding: 16px 0;
                margin: 8px 0;
                cursor: pointer;
            }
            
            .controls-overlay label {
                font-size: 16px !important;
                margin-bottom: 8px !important;
                display: block !important;
            }
            
            /* Poetry overlay mobile adjustments */
            .poetry-overlay {
                height: 30vh; /* Slightly larger on mobile */
                padding: 15px;
                background: linear-gradient(to top, rgba(0, 0, 0, 0.9), rgba(0, 0, 0, 0.4), transparent);
            }
            
            .poetry-text {
                font-size: 1.5em !important;
                line-height: 1.5;
                word-wrap: break-word;
                hyphens: auto;
                max-width: 90vw;
            }
            
            /* Canvas adjustments for mobile */
            #memory-canvas {
                width: 100vw !important;
                height: 100vh !important;
                position: fixed !important;
                top: 0 !important;
                left: 0 !important;
            }
            
            /* Audio prompt mobile optimization */
            #audio-prompt {
                padding: 20px;
            }
            
            #audio-prompt h1 {
                font-size: 1.8em !important;
                margin-bottom: 15px !important;
            }
            
            #audio-prompt p {
                font-size: 1em !important;
                margin-bottom: 20px !important;
            }
            
            #start-audio {
                padding: 18px 25px !important;
                font-size: 1.1em !important;
                min-height: 44px;
                border-radius: 12px !important;
                touch-action: manipulation;
            }
        }
        
        @media screen and (max-width: 480px) {
            /* Extra small mobile devices */
            body {
                font-size: 12px;
            }
            
            .controls-overlay {
                top: 5px;
                left: 5px;
                right: 5px;
                padding: 10px;
                font-size: 12px;
            }
            
            .poetry-overlay {
                height: 28vh; /* Slightly smaller on very small screens */
                padding: 12px;
            }
            
            .poetry-text {
                font-size: 1.4em !important;
                max-width: 95vw;
            }
            
            #audio-prompt h1 {
                font-size: 1.5em !important;
            }
            
            #start-audio {
                padding: 15px 20px !important;
                font-size: 1em !important;
            }
        }
        
        @media screen and (orientation: landscape) and (max-height: 500px) {
            /* Landscape mobile optimization */
            .controls-overlay {
                top: 5px;
                left: 5px;
                padding: 8px;
                font-size: 11px;
            }
            
            .poetry-overlay {
                height: 35vh; /* Larger portion in landscape for readability */
                padding: 8px;
                background: linear-gradient(to top, rgba(0, 0, 0, 0.85), rgba(0, 0, 0, 0.3), transparent);
            }
            
            .poetry-text {
                font-size: 1.3em !important;
                max-width: 80vw;
                line-height: 1.4;
            }
        }

        .fade-in {
            animation: fadeIn 2s ease-in;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .glow {
            box-shadow: 0 0 30px rgba(0, 255, 136, 0.5);
        }

        /* Hypnotic effects */
        .kaleidoscope {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
            background: 
                radial-gradient(circle at 25% 25%, rgba(0, 255, 136, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 75% 25%, rgba(0, 187, 255, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 25% 75%, rgba(255, 0, 136, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 75% 75%, rgba(136, 0, 255, 0.1) 0%, transparent 50%);
            animation: rotate 20s linear infinite;
        }

        @keyframes rotate {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        .particle-system {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            pointer-events: none;
        }

        .particle {
            position: absolute;
            width: 4px;
            height: 4px;
            background: radial-gradient(circle, rgba(0, 255, 136, 0.8), transparent);
            border-radius: 50%;
            animation: float 8s ease-in-out infinite;
        }

        @keyframes float {
            0%, 100% { transform: translateY(0) scale(1); opacity: 0.8; }
            50% { transform: translateY(-20px) scale(1.2); opacity: 1; }
        }
    </style>
</head>
<body>
    <div class="hypnotic-container">
        <!-- Kaleidoscope background -->
        <!-- Kaleidoscope - Hidden for pure memory visualization -->
        <div class="kaleidoscope" style="display: none;"></div>
        
        <!-- 3D Dendrite Canvas -->
        <canvas id="dendrite-canvas"></canvas>
        
        <!-- Particle System - Hidden for pure memory visualization -->
        <div class="particle-system" id="particle-system" style="display: none;"></div>
        
        <!-- Poetry Overlay -->
        <div class="poetry-overlay">
            <div class="poetry-text" id="poetry-text">
                Memory Objects Visualizer
            </div>
        </div>
        
        <!-- Minimal interaction prompt for audio -->
        <div id="audio-prompt" style="position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: rgba(0,0,0,0.95); z-index: 1000; display: flex; align-items: center; justify-content: center; flex-direction: column;">
            <div style="text-align: center; color: #00ff88;">
                <h1 style="font-size: 2.5em; margin-bottom: 20px; text-shadow: 0 0 20px rgba(0, 255, 136, 0.8);">Memory Objects Visualizer</h1>
                <p style="font-size: 1.2em; margin-bottom: 30px; opacity: 0.8;">Autonomous dendritic memory system with musical composition</p>
                <button id="start-audio" style="padding: 15px 30px; font-size: 1.3em; background: linear-gradient(45deg, #00ff88, #00bbff); color: #000; border: none; border-radius: 8px; cursor: pointer; font-weight: bold; box-shadow: 0 0 20px rgba(0, 255, 136, 0.5);">
                    🧠 ACTIVATE MEMORY SYSTEM 🎵
                </button>
                <p style="font-size: 0.9em; margin-top: 15px; opacity: 0.6;">Click to begin autonomous audiovisual experience</p>
            </div>
        </div>
        
        <!-- Audio Visualizer -->
        <div class="audio-visualizer">
            <canvas class="waveform" id="waveform-canvas"></canvas>
        </div>
    </div>

    <!-- Volume Control Only -->
    <div class="controls-overlay">
        <!-- Volume Control -->
        <div style="margin: 15px 0; padding: 10px; background: rgba(0,0,0,0.3); border-radius: 5px;">
            <label style="display: block; margin-bottom: 5px; color: #00ff88;">🔊 Volume</label>
            <input type="range" id="volume-slider" min="0" max="100" value="30" 
                   style="width: 100%; background: linear-gradient(to right, #00ff88, #00bbff); height: 6px; border-radius: 3px; outline: none;">
            <div style="text-align: center; font-size: 12px; color: #888; margin-top: 5px;">
                <span id="volume-display">30%</span>
            </div>
        </div>
    </div>



    <script>
        // ============================================================================
        // Beat Generation Interactive Poetry Machine - Web Edition
        // Combining M5Cardputer learnings with 3D dendrite graphics
        // ============================================================================

        class BeatGenerationMachine {
                         constructor() {
                 this.canvas = document.getElementById('dendrite-canvas');
                 this.gl = null;
                 this.audioContext = null;
                 this.audioEngine = null;
                 this.visualEngine = null;
                 this.poetryEngine = null;
                 this.interactionEngine = null;
                 this.markovChain = null;
                 
                 // Mobile detection and optimization
                 this.isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                 this.isTouch = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
                 
                 // Typewriter effect variables
                 this.typewriterTimeout = null;
                 this.displayTimeout = null;
                
                // Animation state
                this.isRunning = false;
                this.lastFrameTime = 0;
                this.frameTime = 0;
                this.smoothFrameTime = 1/60;
                this.frameTimeSmoothing = 0.9;
                
                // Music-driven visual state
                this.musicEnergy = 0;
                this.bassLevel = 0;
                this.trebleLevel = 0;
                this.rhythmPulse = 0;
                
                // Smooth interpolated values for video-smooth animation
                this.smoothMusicEnergy = { current: 0, target: 0, velocity: 0, smoothing: 0.85 };
                this.smoothBassLevel = { current: 0, target: 0, velocity: 0, smoothing: 0.85 };
                this.smoothTrebleLevel = { current: 0, target: 0, velocity: 0, smoothing: 0.85 };
                this.smoothRhythmPulse = { current: 0, target: 0, velocity: 0, smoothing: 0.85 };
                
                // Animation curves
                this.animationBounce = 0;
                this.animationWave = 0;
                this.animationSpiral = 0;
                this.animationPulse = 0;
                this.smoothTime = 0;
                this.masterTime = 0;
                
                                                 // Current state
                this.currentMode = 'jazz_fusion';
                this.currentPoetry = 0;
                this.hypnoticMode = false;
                
                // Phase Evolution System
                this.phaseSystem = {
                    currentPhase: 0,
                    phaseStartTime: 0,
                    phaseDuration: 60000, // 60 seconds per phase
                    phases: [
                        { name: 'emergence', complexity: 0.1, tempo: 30, markovActivity: 0.2 },
                        { name: 'growth', complexity: 0.3, tempo: 45, markovActivity: 0.4 },
                        { name: 'complexity', complexity: 0.7, tempo: 80, markovActivity: 0.8 },
                        { name: 'chaos', complexity: 1.0, tempo: 120, markovActivity: 1.0 },
                        { name: 'resolution', complexity: 0.6, tempo: 90, markovActivity: 0.7 },
                        { name: 'simplification', complexity: 0.3, tempo: 60, markovActivity: 0.4 },
                        { name: 'meditation', complexity: 0.1, tempo: 35, markovActivity: 0.2 }
                    ],
                    transitionProgress: 0
                };
                 
                 // Complete Interactive Parameters from M5Cardputer
                 this.params = {
                     // Audio Parameters
                     masterVolume: 0.7,
                     tempo: 45.0, // Much slower for relaxing experience
                     harmonicRichness: 0.5,
                     reverbAmount: 0.3,
                     bassBoost: 0.4,
                     trebleBoost: 0.4,
                     chordSpread: 0.5,
                     melodyOctave: 1.0,
                     
                     // Visual Parameters
                     colorIntensity: 0.7,
                     animationSpeed: 0.6,
                     particleDensity: 0.5,
                     textSize: 0.5,
                     backgroundComplexity: 0.6,
                     pulseStrength: 0.8,
                     spiralTightness: 0.5,
                     waveformGain: 0.6,
                     
                     // Markov Parameters
                     markovMemory: 0.5,
                     transitionRate: 0.4,
                     explorationFactor: 0.3,
                     learningRate: 0.1,
                     stateStability: 0.6,
                     predictionWeight: 0.4,
                     adaptationSpeed: 0.2,
                     complexityBias: 0.5,
                     
                     // Advanced Algorithm Parameters
                     annealingRate: 0.5,
                     particleCount: 0.6,
                     bayesianConfidence: 0.7,
                     dendriticDepth: 0.4,
                     temperatureControl: 0.5,
                     samplingDiversity: 0.6,
                     convergenceRate: 0.3,
                     noiseFloor: 0.1,
                     
                     // Poetry Parameters
                     lineIntensity: 0.8,
                     wordSpacing: 0.5,
                     emotionalWeight: 0.7,
                     rhythmSync: 0.6,
                     semanticFlow: 0.5,
                     metaphorDensity: 0.4,
                     imageVividness: 0.8,
                     narrativeCoherence: 0.6
                 };
                 
                 this.init();
            }
            
            updatePhaseEvolution() {
                const now = Date.now();
                if (!this.phaseSystem.phaseStartTime) {
                    this.phaseSystem.phaseStartTime = now;
                }
                
                const elapsed = now - this.phaseSystem.phaseStartTime;
                const progress = elapsed / this.phaseSystem.phaseDuration;
                
                // Check if we need to advance to next phase
                if (progress >= 1.0) {
                    this.phaseSystem.currentPhase = (this.phaseSystem.currentPhase + 1) % this.phaseSystem.phases.length;
                    this.phaseSystem.phaseStartTime = now;
                    this.phaseSystem.transitionProgress = 0;
                    
                    const phase = this.phaseSystem.phases[this.phaseSystem.currentPhase];
                    console.log(`🌊 Phase transition to: ${phase.name} (complexity: ${phase.complexity})`);
                    this.updatePoetryText(`Phase: ${phase.name.toUpperCase()}`);
                } else {
                    this.phaseSystem.transitionProgress = progress;
                }
                
                // Apply current phase parameters
                this.applyPhaseParameters();
            }
            
            applyPhaseParameters() {
                const currentPhase = this.phaseSystem.phases[this.phaseSystem.currentPhase];
                const nextPhaseIndex = (this.phaseSystem.currentPhase + 1) % this.phaseSystem.phases.length;
                const nextPhase = this.phaseSystem.phases[nextPhaseIndex];
                
                // Smooth interpolation between phases
                const t = this.phaseSystem.transitionProgress;
                const smoothT = this.easeInOutCubic(t);
                
                // Interpolate complexity
                const complexity = this.lerp(currentPhase.complexity, nextPhase.complexity, smoothT * 0.1);
                
                // Interpolate tempo
                const tempo = this.lerp(currentPhase.tempo, nextPhase.tempo, smoothT * 0.1);
                
                // Interpolate Markov activity
                const markovActivity = this.lerp(currentPhase.markovActivity, nextPhase.markovActivity, smoothT * 0.1);
                
                // Apply to systems
                this.params.tempo = tempo;
                if (this.audioEngine) {
                    this.audioEngine.currentBPM = tempo;
                    this.audioEngine.beatInterval = 60 / tempo;
                }
                
                if (this.markovChain) {
                    this.markovChain.learningRate = 0.05 + markovActivity * 0.15;
                    this.markovChain.explorationFactor = 0.1 + markovActivity * 0.4;
                    
                    // Adjust node activation based on complexity
                    this.markovChain.dendriticNodes.forEach(node => {
                        node.threshold = 0.3 + (1 - complexity) * 0.5;
                        if (Math.random() < complexity * 0.1) {
                            node.activation += markovActivity * 0.1;
                        }
                    });
                }
                
                // Update visual parameters based on complexity
                this.params.colorIntensity = 0.3 + complexity * 0.7;
                this.params.animationSpeed = 0.2 + complexity * 0.8;
                this.params.pulseStrength = 0.4 + complexity * 0.6;
            }
            
            lerp(a, b, t) {
                return a + (b - a) * Math.max(0, Math.min(1, t));
            }
            
            easeInOutCubic(t) {
                return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
            }
            
            startAnimationLoop() {
                const animate = (currentTime) => {
                    // Calculate frame time
                    if (this.lastFrameTime) {
                        this.frameTime = (currentTime - this.lastFrameTime) / 1000;
                    } else {
                        this.frameTime = 1/60; // Default to 60fps
                    }
                    this.lastFrameTime = currentTime;
                    
                    // Update master time
                    this.masterTime += this.frameTime;
                    this.smoothTime = this.masterTime;
                    
                    // Update phase evolution system
                    this.updatePhaseEvolution();
                    
                    // Update audio analysis
                    this.updateAudio();
                    
                    // Update visuals
                    this.updateVisuals();
                    
                    // Update poetry
                    this.updatePoetry();
                    
                    // Update status display
                    this.updateStatus();
                    
                    // Render the scene
                    this.render();
                    
                    // Continue animation loop
                    requestAnimationFrame(animate);
                };
                
                // Start the loop
                requestAnimationFrame(animate);
                console.log('🎬 Animation loop started with phase evolution');
            }
            
            async init() {
                try {
                    this.init2DCanvas();
                    await this.initAudio();
                    this.initVisuals();
                    this.initPoetry();
                    this.initInteraction();
                    this.startAnimationLoop();
                    
                    console.log('🎵 Beat Generation Machine initialized successfully!');
                    this.updatePoetryText("Memory Objects Visualizer");
                } catch (error) {
                    console.error('Initialization failed:', error);
                    this.updatePoetryText("Error initializing the machine...");
                }
            }
            
            init2DCanvas() {
                // Set up canvas for 2D rendering with mobile optimization
                const devicePixelRatio = this.isMobile ? Math.min(window.devicePixelRatio, 2) : window.devicePixelRatio;
                
                this.canvas.width = window.innerWidth * devicePixelRatio;
                this.canvas.height = window.innerHeight * devicePixelRatio;
                
                // Get 2D context
                this.ctx = this.canvas.getContext('2d');
                if (!this.ctx) {
                    throw new Error('2D Canvas context not supported');
                }
                
                // Scale context for high DPI displays but limit on mobile
                this.ctx.scale(devicePixelRatio, devicePixelRatio);
                
                // Mobile-specific optimizations
                if (this.isMobile) {
                    this.ctx.imageSmoothingEnabled = true;
                    this.ctx.imageSmoothingQuality = 'medium';
                }
                
                // Set up canvas styling
                this.canvas.style.position = 'fixed';
                this.canvas.style.top = '0';
                this.canvas.style.left = '0';
                this.canvas.style.width = '100vw';
                this.canvas.style.height = '100vh';
                this.canvas.style.zIndex = '1';
                
                // Handle resize and orientation changes
                const resizeHandler = () => {
                    const newDevicePixelRatio = this.isMobile ? Math.min(window.devicePixelRatio, 2) : window.devicePixelRatio;
                    this.canvas.width = window.innerWidth * newDevicePixelRatio;
                    this.canvas.height = window.innerHeight * newDevicePixelRatio;
                    this.ctx.scale(newDevicePixelRatio, newDevicePixelRatio);
                    
                    if (this.isMobile) {
                        this.ctx.imageSmoothingEnabled = true;
                        this.ctx.imageSmoothingQuality = 'medium';
                    }
                };
                
                window.addEventListener('resize', resizeHandler);
                window.addEventListener('orientationchange', () => {
                    setTimeout(resizeHandler, 100); // Delay for orientation change
                });
                
                console.log('2D Canvas initialized for pure memory visualization:', this.canvas.width, 'x', this.canvas.height, 'Mobile:', this.isMobile, 'DPR:', devicePixelRatio);
            }
            
            // Legacy WebGL method - no longer used
            async initWebGL() {
                this.gl = this.canvas.getContext('webgl2') || 
                          this.canvas.getContext('webgl') || 
                          this.canvas.getContext('experimental-webgl');
                
                if (!this.gl) {
                    throw new Error('WebGL not supported');
                }
                
                this.resizeCanvas();
                this.setupShaders();
                this.setupWebGLState();
                
                // Initialize dendrite system
                this.dendrites = new DendriticSystem(this.gl);
                
                window.addEventListener('resize', () => this.resizeCanvas());
            }
            
            async initAudio() {
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    this.audioEngine = new JazzAudioEngine(this.audioContext, this.params);
                    
                    console.log('Audio context created:', this.audioContext.state);
                    
                    // Auto-resume audio context for autonomous mode
                    const autoResumeAudio = async () => {
                        if (this.audioContext.state === 'suspended') {
                            try {
                                await this.audioContext.resume();
                                console.log('🎵 Audio context auto-resumed:', this.audioContext.state);
                            } catch (error) {
                                console.log('Auto-resume failed, waiting for user interaction');
                            }
                        }
                    };
                    
                    // Try to auto-resume immediately
                    await autoResumeAudio();
                    
                    // Also add fallback user interaction listeners
                    document.addEventListener('click', autoResumeAudio);
                    document.addEventListener('keydown', autoResumeAudio);
                    document.addEventListener('touchstart', autoResumeAudio);
                    
                    // Audio will be started by user gesture
                    console.log('🎵 Audio engine ready, waiting for activation');
                    
                } catch (error) {
                    console.error('Audio initialization failed:', error);
                    this.updatePoetryText("Audio system initializing...");
                }
            }
            
                         initVisuals() {
                 this.visualEngine = new HypnoticVisualEngine(this.canvas, this.gl);
                 this.particleSystem = new ParticleSystem();
                 this.markovChain = new DendriticMarkovChain();
                 
                 // Connect memory structure to audio engine
                 if (this.audioEngine) {
                     this.audioEngine.setMemoryStructure(this.markovChain);
                     console.log('🧠 Memory structure connected to audio engine');
                 }
             }
             
             initPoetry() {
                 this.poetryEngine = new PoetryEngine();
                 this.currentPoetryLine = 0;
                  
                  // Connect poetry engine to dendritic memory for NLP evolution
                  if (this.markovChain) {
                      this.poetryEngine.setMemoryStructure(this.markovChain);
                      this.markovChain.poetryEngineRef = this.poetryEngine; // Reference for evolution notifications
                  }
             }
            
            initInteraction() {
                // Non-interactive mode - no keyboard controls
                console.log('🚫 Interactive controls disabled - autonomous mode');
            }
            
            setupShaders() {
                const vertexShaderSource = `
                    precision mediump float;
                    attribute vec3 a_position;
                    attribute float a_thickness;
                    attribute float a_time;
                    uniform mat4 u_matrix;
                    uniform float u_globalTime;
                    uniform float u_musicEnergy;
                    uniform float u_bassLevel;
                    uniform float u_rhythmPulse;
                    varying float v_thickness;
                    varying vec3 v_position;
                    varying float v_energy;
                    
                    void main() {
                        // Music-responsive vertex animation
                        vec3 pos = a_position;
                        
                        // Breathing effect based on music energy
                        float breathe = sin(u_globalTime * 2.0 + a_time) * u_musicEnergy * 0.5;
                        pos += normalize(pos) * breathe;
                        
                        // Bass-driven expansion
                        pos *= (1.0 + u_bassLevel * 0.3);
                        
                        // Rhythm pulse
                        float pulse = u_rhythmPulse * 0.2;
                        pos += vec3(sin(u_globalTime * 4.0), cos(u_globalTime * 3.0), 0.0) * pulse;
                        
                        gl_Position = u_matrix * vec4(pos, 1.0);
                        v_thickness = a_thickness * (1.0 + u_rhythmPulse * 0.5);
                        v_position = pos;
                        v_energy = u_musicEnergy;
                        gl_PointSize = v_thickness * 3.0;
                    }
                `;
                
                const fragmentShaderSource = `
                    precision mediump float;
                    uniform float u_globalTime;
                    uniform float u_musicEnergy;
                    uniform float u_bassLevel;
                    uniform float u_trebleLevel;
                    uniform float u_rhythmPulse;
                    varying float v_thickness;
                    varying vec3 v_position;
                    varying float v_energy;
                    
                    vec3 hsv2rgb(vec3 c) {
                        vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
                        vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
                        return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
                    }
                    
                    void main() {
                        // Enhanced music-driven color animation for maximum visibility
                        float hue = fract(u_globalTime * 0.15 + v_position.x * 0.02 + u_musicEnergy * 0.3);
                        float saturation = 0.85 + u_bassLevel * 0.15;
                        float brightness = 0.8 + u_rhythmPulse * 0.2 + v_energy * 0.2;
                        
                        // More pronounced hypnotic color shifting
                        hue += sin(u_globalTime * 3.0 + v_position.y * 0.03) * 0.2;
                        
                        vec3 color = hsv2rgb(vec3(hue, saturation, brightness));
                        
                        // Enhanced visibility with higher base alpha
                        float alpha = 0.9 + sin(u_globalTime * 6.0 + v_position.z * 0.05) * u_rhythmPulse * 0.1;
                        alpha = clamp(alpha, 0.7, 1.0); // Ensure minimum visibility
                        
                        // Stronger glow effect for 3D depth perception
                        float glow = 1.3 + u_trebleLevel * 0.7 + v_thickness * 0.2;
                        color *= glow;
                        
                        // Add edge highlighting for better 3D definition
                        float edgeHighlight = 1.0 + abs(sin(v_position.x + v_position.y + v_position.z)) * 0.3;
                        color *= edgeHighlight;
                        
                        gl_FragColor = vec4(color, alpha);
                    }
                `;
                
                this.shaderProgram = this.createShaderProgram(vertexShaderSource, fragmentShaderSource);
                this.gl.useProgram(this.shaderProgram);
                
                this.attributes = {
                    position: this.gl.getAttribLocation(this.shaderProgram, 'a_position'),
                    thickness: this.gl.getAttribLocation(this.shaderProgram, 'a_thickness'),
                    time: this.gl.getAttribLocation(this.shaderProgram, 'a_time')
                };
                
                this.uniforms = {
                    matrix: this.gl.getUniformLocation(this.shaderProgram, 'u_matrix'),
                    globalTime: this.gl.getUniformLocation(this.shaderProgram, 'u_globalTime'),
                    musicEnergy: this.gl.getUniformLocation(this.shaderProgram, 'u_musicEnergy'),
                    bassLevel: this.gl.getUniformLocation(this.shaderProgram, 'u_bassLevel'),
                    trebleLevel: this.gl.getUniformLocation(this.shaderProgram, 'u_trebleLevel'),
                    rhythmPulse: this.gl.getUniformLocation(this.shaderProgram, 'u_rhythmPulse')
                };
            }
            
            createShaderProgram(vertexSource, fragmentSource) {
                const vertexShader = this.createShader(this.gl.VERTEX_SHADER, vertexSource);
                const fragmentShader = this.createShader(this.gl.FRAGMENT_SHADER, fragmentSource);
                
                const program = this.gl.createProgram();
                this.gl.attachShader(program, vertexShader);
                this.gl.attachShader(program, fragmentShader);
                this.gl.linkProgram(program);
                
                if (!this.gl.getProgramParameter(program, this.gl.LINK_STATUS)) {
                    console.error('Program linking error:', this.gl.getProgramInfoLog(program));
                    return null;
                }
                
                return program;
            }
            
            createShader(type, source) {
                const shader = this.gl.createShader(type);
                this.gl.shaderSource(shader, source);
                this.gl.compileShader(shader);
                
                if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
                    console.error('Shader compilation error:', this.gl.getShaderInfoLog(shader));
                    this.gl.deleteShader(shader);
                    return null;
                }
                
                return shader;
            }
            
            setupWebGLState() {
                this.gl.enable(this.gl.BLEND);
                this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA);
                // Enhanced WebGL setup for better 3D visibility
                this.gl.enable(this.gl.DEPTH_TEST);
                this.gl.depthFunc(this.gl.LEQUAL);
                this.gl.enable(this.gl.BLEND);
                this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA);
                this.gl.clearColor(0.02, 0.02, 0.08, 1.0);
                
                // Ensure proper canvas sizing
                this.canvas.width = this.canvas.clientWidth;
                this.canvas.height = this.canvas.clientHeight;
            }
            
            resizeCanvas() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
                
                if (this.gl) {
                    this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);
                }
            }
            
                         setupKeyboardControls() {
                 document.addEventListener('keydown', async (e) => {
                     // Ensure audio context is ready
                     if (this.audioContext && this.audioContext.state === 'suspended') {
                         await this.audioContext.resume();
                     }
                     
                     const key = e.key.toLowerCase();
                     
                     // Complete keyboard mapping from M5Cardputer
                     switch (key) {
                         // Special controls
                         case ' ':
                             e.preventDefault();
                             await this.toggleAudio();
                             break;
                         case 'tab':
                             e.preventDefault();
                             this.toggleHypnoticMode();
                             break;
                         case 'escape':
                             this.resetAll();
                             break;
                             
                         // Row 1 - Audio Parameters (QWERTY...)
                         case 'q': this.adjustParameter('masterVolume', 0.1, 1.0, 0.02); break;
                         case 'w': this.adjustParameter('tempo', 30.0, 120.0, 2.0); break;
                         case 'e': this.adjustParameter('harmonicRichness', 0.0, 1.0, 0.02); break;
                         case 'r': this.adjustParameter('reverbAmount', 0.0, 1.0, 0.02); break;
                         case 't': this.adjustParameter('bassBoost', 0.0, 1.0, 0.02); break;
                         case 'y': this.adjustParameter('trebleBoost', 0.0, 1.0, 0.02); break;
                         case 'u': this.adjustParameter('chordSpread', 0.0, 1.0, 0.02); break;
                         case 'i': this.adjustParameter('melodyOctave', 0.5, 2.0, 0.02); break;
                         case 'o': this.adjustParameter('colorIntensity', 0.0, 1.0, 0.02); break;
                         case 'p': this.adjustParameter('animationSpeed', 0.1, 2.0, 0.02); break;
                         
                         // Row 2 - Visual Parameters (ASDF...)
                         case 'a': this.adjustParameter('particleDensity', 0.0, 1.0, 0.02); break;
                         case 's': this.adjustParameter('textSize', 0.3, 2.0, 0.02); break;
                         case 'd': this.adjustParameter('backgroundComplexity', 0.0, 1.0, 0.02); break;
                         case 'f': this.adjustParameter('pulseStrength', 0.0, 1.0, 0.02); break;
                         case 'g': this.adjustParameter('spiralTightness', 0.0, 1.0, 0.02); break;
                         case 'h': this.adjustParameter('waveformGain', 0.0, 2.0, 0.02); break;
                         case 'j': this.adjustParameter('markovMemory', 0.0, 1.0, 0.02); break;
                         case 'k': this.adjustParameter('transitionRate', 0.0, 1.0, 0.02); break;
                         case 'l': this.adjustParameter('explorationFactor', 0.0, 1.0, 0.02); break;
                         
                         // Row 3 - Markov Parameters (ZXCV...)
                         case 'z': this.adjustParameter('learningRate', 0.01, 0.5, 0.01); break;
                         case 'x': this.adjustParameter('stateStability', 0.0, 1.0, 0.02); break;
                         case 'c': this.adjustParameter('predictionWeight', 0.0, 1.0, 0.02); break;
                         case 'v': this.adjustParameter('adaptationSpeed', 0.0, 1.0, 0.02); break;
                         case 'b': this.adjustParameter('complexityBias', 0.0, 1.0, 0.02); break;
                         case 'n': this.adjustParameter('annealingRate', 0.0, 1.0, 0.02); break;
                         case 'm': this.adjustParameter('particleCount', 0.1, 1.0, 0.02); break;
                         
                         // Numbers - Advanced Algorithm Parameters
                         case '1': this.adjustParameter('bayesianConfidence', 0.0, 1.0, 0.02); break;
                         case '2': this.adjustParameter('dendriticDepth', 0.0, 1.0, 0.02); break;
                         case '3': this.adjustParameter('temperatureControl', 0.0, 1.0, 0.02); break;
                         case '4': this.adjustParameter('samplingDiversity', 0.0, 1.0, 0.02); break;
                         case '5': this.adjustParameter('convergenceRate', 0.0, 1.0, 0.02); break;
                         case '6': this.adjustParameter('noiseFloor', 0.0, 0.5, 0.02); break;
                         case '7': this.adjustParameter('lineIntensity', 0.0, 1.0, 0.02); break;
                         case '8': this.adjustParameter('wordSpacing', 0.3, 2.0, 0.02); break;
                         case '9': this.adjustParameter('emotionalWeight', 0.0, 1.0, 0.02); break;
                         case '0': this.adjustParameter('rhythmSync', 0.0, 1.0, 0.02); break;
                         
                         // Special characters - Poetry Parameters
                         case '.': this.adjustParameter('metaphorDensity', 0.0, 1.0, 0.02); break;
                         case ',': this.adjustParameter('imageVividness', 0.0, 1.0, 0.02); break;
                         case '/': this.adjustParameter('narrativeCoherence', 0.0, 1.0, 0.02); break;
                         
                         default:
                             break;
                     }
                 });
             }
            
            startAnimationLoop() {
                this.isRunning = true;
                const animate = (currentTime) => {
                    if (!this.isRunning) return;
                    
                    this.updateTiming(currentTime);
                    this.updateAudio();
                    this.updateVisuals();
                    this.updatePoetry();
                    this.render();
                    this.updateStatus();
                    
                    requestAnimationFrame(animate);
                };
                requestAnimationFrame(animate);
            }
            
            updateTiming(currentTime) {
                this.frameTime = (currentTime - this.lastFrameTime) * 0.001;
                this.lastFrameTime = currentTime;
                
                // Smooth frame time for video-like consistency
                this.smoothFrameTime = this.smoothFrameTime * this.frameTimeSmoothing + 
                                     this.frameTime * (1.0 - this.frameTimeSmoothing);
                
                // Use smooth frame time for animations
                const animFrameTime = Math.max(0.008, Math.min(0.033, this.smoothFrameTime));
                
                this.smoothTime += animFrameTime;
                this.masterTime = currentTime * 0.001;
                
                // Update smooth interpolated values
                this.updateSmoothInterpolation();
                
                // Update animation curves
                this.updateAnimationCurves();
            }
            
            updateSmoothInterpolation() {
                this.updateInterpolatedValue(this.smoothMusicEnergy, this.musicEnergy);
                this.updateInterpolatedValue(this.smoothBassLevel, this.bassLevel);
                this.updateInterpolatedValue(this.smoothTrebleLevel, this.trebleLevel);
                this.updateInterpolatedValue(this.smoothRhythmPulse, this.rhythmPulse);
            }
            
            updateInterpolatedValue(smooth, target) {
                const diff = target - smooth.current;
                smooth.velocity = smooth.velocity * smooth.smoothing + diff * (1.0 - smooth.smoothing);
                smooth.current += smooth.velocity;
                
                if (Math.abs(diff) < 0.001) {
                    smooth.current = target;
                    smooth.velocity *= 0.9;
                }
            }
            
            updateAnimationCurves() {
                // Professional animation easing curves
                this.animationBounce = this.easeElasticOut(this.smoothTime * 0.5 % 1.0);
                this.animationWave = this.easeSineInOut(this.smoothTime * 0.3 % 1.0);
                this.animationSpiral = this.easeBackInOut(this.smoothTime * 0.4 % 1.0);
                this.animationPulse = this.easeBounceOut((this.smoothTime * 0.6 + this.smoothRhythmPulse.current) % 1.0);
            }
            
            // Animation easing functions
            easeElasticOut(t) {
                if (t === 0 || t === 1) return t;
                const p = 0.3;
                return Math.pow(2, -10 * t) * Math.sin((t - p/4) * (2 * Math.PI) / p) + 1;
            }
            
            easeSineInOut(t) {
                return -(Math.cos(Math.PI * t) - 1) / 2;
            }
            
            easeBackInOut(t) {
                const c1 = 1.70158;
                const c2 = c1 * 1.525;
                return t < 0.5
                    ? (Math.pow(2 * t, 2) * ((c2 + 1) * 2 * t - c2)) / 2
                    : (Math.pow(2 * t - 2, 2) * ((c2 + 1) * (t * 2 - 2) + c2) + 2) / 2;
            }
            
            easeBounceOut(t) {
                const n1 = 7.5625;
                const d1 = 2.75;
                
                if (t < 1 / d1) {
                    return n1 * t * t;
                } else if (t < 2 / d1) {
                    return n1 * (t -= 1.5 / d1) * t + 0.75;
                } else if (t < 2.5 / d1) {
                    return n1 * (t -= 2.25 / d1) * t + 0.9375;
                } else {
                    return n1 * (t -= 2.625 / d1) * t + 0.984375;
                }
            }
            
                         updateAudio() {
                 if (this.audioEngine) {
                     const audioData = this.audioEngine.getAudioData();
                     this.musicEnergy = audioData.energy;
                     this.bassLevel = audioData.bass;
                     this.trebleLevel = audioData.treble;
                     this.rhythmPulse = audioData.rhythmPulse;
                     
                     // Keep tempo stable - use parameter tempo only
                     if (this.audioEngine.currentBPM !== this.params.tempo) {
                         this.audioEngine.currentBPM = this.params.tempo;
                         this.audioEngine.beatInterval = 60 / this.audioEngine.currentBPM;
                     }
                     
                     // Ensure BPM stays within reasonable bounds
                     if (this.audioEngine.currentBPM < 30) {
                         this.audioEngine.currentBPM = 30;
                     } else if (this.audioEngine.currentBPM > 120) {
                         this.audioEngine.currentBPM = 120;
                     }
                     this.audioEngine.beatInterval = 60 / this.audioEngine.currentBPM;
                 }
             }
            
                         updateVisuals() {
                 // Update Markov chain with current state and all parameters
                 if (this.markovChain) {
                     const audioData = {
                         energy: this.smoothMusicEnergy.current,
                         bass: this.smoothBassLevel.current,
                         treble: this.smoothTrebleLevel.current,
                         rhythmPulse: this.smoothRhythmPulse.current,
                         harmonicRichness: this.params.harmonicRichness,
                         bassBoost: this.params.bassBoost,
                         trebleBoost: this.params.trebleBoost
                     };
                     
                     const visualParams = {
                         complexity: this.params.backgroundComplexity,
                         intensity: this.params.colorIntensity,
                         animationSpeed: this.params.animationSpeed,
                         particleDensity: this.params.particleDensity,
                         pulseStrength: this.params.pulseStrength,
                         spiralTightness: this.params.spiralTightness
                     };
                     
                     const poetryParams = {
                         emotionalWeight: this.params.emotionalWeight,
                         lineIntensity: this.params.lineIntensity,
                         imageVividness: this.params.imageVividness,
                         narrativeCoherence: this.params.narrativeCoherence
                     };
                     
                     this.markovChain.updateMarkovState(audioData, visualParams, poetryParams);
                 }
                 
                 if (this.visualEngine) {
                     this.visualEngine.update({
                         musicEnergy: this.smoothMusicEnergy.current,
                         bassLevel: this.smoothBassLevel.current,
                         trebleLevel: this.smoothTrebleLevel.current,
                         rhythmPulse: this.smoothRhythmPulse.current,
                         animationBounce: this.animationBounce,
                         animationWave: this.animationWave,
                         animationSpiral: this.animationSpiral,
                         animationPulse: this.animationPulse,
                         smoothTime: this.smoothTime,
                         hypnoticMode: this.hypnoticMode
                     });
                 }
                 
                 this.updateParticles();
             }
            
                         updatePoetry() {
                 // Update poetry more frequently but still controlled
                 if (!this.lastPoetryUpdate) this.lastPoetryUpdate = 0;
                 const now = Date.now();
                 
                 // Update poetry every 4-6 seconds
                 const minInterval = 4000 + Math.random() * 2000;
                 if (now - this.lastPoetryUpdate < minInterval) return;
                 
                 if (this.poetryEngine && this.markovChain) {
                     const markovPoetryParams = this.markovChain.getPoetryParameters();
                     
                     // Change poetry style based on Markov state occasionally
                     if (markovPoetryParams.style !== this.poetryEngine.currentStyle && Math.random() < 0.15) {
                         this.poetryEngine.setStyle(markovPoetryParams.style);
                     }
                     
                     // Change poetry line more frequently
                     if (Math.random() < 0.7) {
                         this.nextPoetryLine();
                         this.lastPoetryUpdate = now;
                     }
                 }
             }
            
            updateParticles() {
                const particleContainer = document.getElementById('particle-system');
                
                // Add new particles based on music energy
                if (this.smoothMusicEnergy.current > 0.5 && Math.random() < 0.3) {
                    this.createParticle(particleContainer);
                }
            }
            
            createParticle(container) {
                const particle = document.createElement('div');
                particle.className = 'particle';
                
                // Random position
                particle.style.left = Math.random() * window.innerWidth + 'px';
                particle.style.top = Math.random() * window.innerHeight + 'px';
                
                // Music-driven color
                const hue = (this.smoothTime * 50 + this.smoothMusicEnergy.current * 120) % 360;
                const saturation = 70 + this.smoothBassLevel.current * 30;
                const lightness = 50 + this.smoothRhythmPulse.current * 30;
                
                particle.style.background = `radial-gradient(circle, hsl(${hue}, ${saturation}%, ${lightness}%), transparent)`;
                
                // Animation duration based on music
                const duration = 8 - this.smoothMusicEnergy.current * 4;
                particle.style.animationDuration = duration + 's';
                
                container.appendChild(particle);
                
                // Remove particle after animation
                setTimeout(() => {
                    if (particle.parentNode) {
                        particle.parentNode.removeChild(particle);
                    }
                }, duration * 1000);
            }
            
            render() {
                // PURE MEMORY OBJECT VISUALIZATION - No WebGL, only 2D memory structures
                this.renderMemoryObjects();
            }
            
            renderMemoryObjects() {
                // Use the stored 2D context
                if (!this.ctx) {
                    console.error('2D context not available');
                    return;
                }
                
                // Ensure canvas is properly sized
                if (this.canvas.width !== window.innerWidth || this.canvas.height !== window.innerHeight) {
                    this.canvas.width = window.innerWidth;
                    this.canvas.height = window.innerHeight;
                }
                
                // Clear with deep fade to show memory persistence
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Use full canvas size for dendrite field
                const viewWidth = this.canvas.width;
                const viewHeight = this.canvas.height;
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height / 2;
                
                // Draw ONLY the memory object structures
                this.drawMemoryObjectStructure(this.ctx, centerX, centerY, viewWidth, viewHeight);
                
                // Show evolution activity indicator
                this.drawEvolutionIndicator(this.ctx, centerX, centerY, viewWidth, viewHeight);
                
                console.log('Rendered memory objects at', centerX, centerY, 'canvas size:', this.canvas.width, 'x', this.canvas.height);
            }
            
            drawMemoryObjectStructure(ctx, centerX, centerY, viewWidth, viewHeight) {
                if (!this.markovChain) {
                    // Only show memory when Markov chain exists - no fallbacks
                    return;
                }
                
                // Visualize ONLY the main dendritic memory structure - clear and unobscured
                this.drawDendriticMemoryNodes(ctx, centerX, centerY, viewWidth, viewHeight);
                this.drawStateTransitionMemory(ctx, centerX, centerY, viewWidth, viewHeight);
                // Removed parameter structure to avoid visual clutter
            }
            
            drawFallbackSculptures(ctx, centerX, centerY, viewWidth, viewHeight) {
                // Draw beautiful dendritic sculptures even without Markov chain
                const maxRadius = Math.min(viewWidth, viewHeight) * 0.4;
                const numBranches = 12;
                
                for (let i = 0; i < numBranches; i++) {
                    const angle = (i / numBranches) * Math.PI * 2 + this.smoothTime * 0.1;
                    const branchLength = maxRadius * (0.6 + Math.sin(this.smoothTime * 0.3 + i) * 0.3);
                    
                    // Draw main branch
                    ctx.beginPath();
                    ctx.moveTo(centerX, centerY);
                    
                    const segments = 8;
                    for (let seg = 1; seg <= segments; seg++) {
                        const t = seg / segments;
                        const segmentAngle = angle + Math.sin(t * Math.PI * 3 + this.smoothTime) * 0.5;
                        const segmentRadius = branchLength * t;
                        
                        const x = centerX + Math.cos(segmentAngle) * segmentRadius;
                        const y = centerY + Math.sin(segmentAngle) * segmentRadius;
                        
                        ctx.lineTo(x, y);
                        
                        // Add sub-branches
                        if (seg % 2 === 0) {
                            const subAngle = segmentAngle + Math.PI * 0.3;
                            const subLength = segmentRadius * 0.4;
                            const subX = x + Math.cos(subAngle) * subLength;
                            const subY = y + Math.sin(subAngle) * subLength;
                            
                            ctx.moveTo(x, y);
                            ctx.lineTo(subX, subY);
                            ctx.moveTo(x, y);
                        }
                    }
                    
                    const hue = (i * 30 + this.smoothTime * 20) % 360;
                    const alpha = 0.8 + this.smoothMusicEnergy.current * 0.2;
                    
                    ctx.strokeStyle = `hsla(${hue}, 80%, 70%, ${alpha})`;
                    ctx.lineWidth = 3 + this.smoothMusicEnergy.current * 4;
                    ctx.stroke();
                }
            }
            
            drawDendriticMemoryNodes(ctx, centerX, centerY, viewWidth, viewHeight) {
                if (!this.markovChain.dendriticNodes) return;
                
                const nodes = this.markovChain.dendriticNodes;
                
                // Scale to fit viewport while preserving dendritic structure - increased for mobile visibility
                const scale = Math.min(viewWidth, viewHeight) / (this.isMobile ? 600 : 800); // Larger scaling on mobile
                
                // Calculate maxRadius to ensure nodes stay within bounds (account for margins and node size)
                const margin = 50;
                const maxNodeSize = scale * (this.isMobile ? 2.5 : 2.0) * 2; // Account for largest possible node size
                const availableWidth = viewWidth - (margin * 2) - maxNodeSize;
                const availableHeight = viewHeight - (margin * 2) - maxNodeSize;
                const maxRadius = Math.min(availableWidth, availableHeight) * 0.4;
                
                // Mobile performance optimization - limit node count for rendering
                const maxNodesToRender = this.isMobile ? 40 : nodes.length;
                const nodesToRender = nodes.slice(0, maxNodesToRender);
                
                // Get currently active nodes for music generation
                const activeNodes = this.markovChain.dendriticNodes.filter(node => node.activation > node.threshold);
                const currentTime = Date.now();
                
                nodesToRender.forEach((node, index) => {
                    if (node.activation < node.threshold) return;
                    
                    // Stable dendritic positioning based on node ID (not array index) for consistency during evolution
                    const baseAngle = (node.id * 137.5) * (Math.PI / 180); // Golden angle for natural distribution
                    const memoryLayer = Math.floor(node.id / 10); // Group nodes into memory layers based on ID
                    const dendriticRadius = maxRadius * (0.3 + memoryLayer * 0.15); // Stable radius based on memory layer
                    
                    // Subtle organic movement - much less dramatic
                    const organicAngle = baseAngle + Math.sin(this.smoothTime * 0.05 + node.id * 0.1) * 0.1;
                    
                    const x = centerX + Math.cos(organicAngle) * dendriticRadius;
                    const y = centerY + Math.sin(organicAngle) * dendriticRadius;
                    
                    // Strict containment - ensure nodes stay within canvas bounds
                    const margin = 50;
                    const nodeRadius = scale * (this.isMobile ? 2.5 : 2.0) * 1.5; // Account for node size and glow effects
                    const minX = margin + nodeRadius;
                    const maxX = viewWidth - margin - nodeRadius;
                    const minY = margin + nodeRadius;
                    const maxY = viewHeight - margin - nodeRadius;
                    
                    // Clamp positions strictly within bounds
                    let finalX = Math.max(minX, Math.min(maxX, x));
                    let finalY = Math.max(minY, Math.min(maxY, y));
                    
                    // If position was clamped, ensure it's still within the natural distribution
                    const distFromCenter = Math.sqrt((finalX - centerX) ** 2 + (finalY - centerY) ** 2);
                    if (distFromCenter > maxRadius) {
                        const scaleFactor = maxRadius / distFromCenter;
                        finalX = centerX + (finalX - centerX) * scaleFactor;
                        finalY = centerY + (finalY - centerY) * scaleFactor;
                        
                        // Final safety clamp
                        finalX = Math.max(minX, Math.min(maxX, finalX));
                        finalY = Math.max(minY, Math.min(maxY, finalY));
                    }
                    
                    // Determine if this node is currently being used for music generation
                    const isActivelyPlaying = node.isCurrentlyGeneratingMusic || false;
                    const isRecentlyUsedForMusic = node.lastMusicGenerationTime && (currentTime - node.lastMusicGenerationTime < 2000);
                    const isRecentlyActive = node.lastActivationTime && (currentTime - node.lastActivationTime < 5000);
                    const isHighlyActive = node.activation > node.threshold * 1.5;
                    
                    // Draw consistent memory node with enhanced visuals for active states
                    let nodeSize = scale * (this.isMobile ? 2.5 : 2.0); // Larger base size, especially on mobile
                    let hue = 200 + (node.id * 30) % 120; // Blue-cyan range
                    let saturation = 30 + this.params.colorIntensity * 20;
                    let alpha = 0.3 + node.activation * 0.5;
                    
                    // Visual enhancements for active nodes
                    if (isActivelyPlaying) {
                        // Gentle pulsing effect for nodes currently generating music - each node has unique timing
                        const uniqueOffset = node.id * 0.7; // Each node gets unique timing offset
                        const pulseIntensity = 0.3 + 0.2 * Math.sin(this.smoothTime * 2 + uniqueOffset);
                        nodeSize *= (1.15 + pulseIntensity * 0.15);
                        hue = 30 + (node.id * 15) % 40; // Bright orange-red range for actively playing
                        saturation = 70 + this.params.colorIntensity * 20;
                        alpha = 0.8 + pulseIntensity * 0.2;
                        
                        // Add gentle glowing outer ring for actively playing nodes
                        ctx.beginPath();
                        ctx.arc(finalX, finalY, nodeSize * 1.6, 0, Math.PI * 2);
                        ctx.fillStyle = `hsla(${hue}, ${saturation}%, 80%, ${0.2 + pulseIntensity * 0.15})`;
                        ctx.fill();
                    } else if (isRecentlyUsedForMusic) {
                        // Warm glow for recently used for music generation
                        const fadeIntensity = Math.max(0, 1 - (currentTime - node.lastMusicGenerationTime) / 2000);
                        hue = 50 + (node.id * 20) % 50; // Warm yellow-orange range
                        saturation = 60 + this.params.colorIntensity * 25;
                        alpha = 0.6 + fadeIntensity * 0.3;
                        nodeSize *= (1.15 + fadeIntensity * 0.15);
                        
                        // Add fading glow ring
                        ctx.beginPath();
                        ctx.arc(finalX, finalY, nodeSize * (1.4 + fadeIntensity * 0.4), 0, Math.PI * 2);
                        ctx.fillStyle = `hsla(${hue}, ${saturation}%, 75%, ${0.2 + fadeIntensity * 0.2})`;
                        ctx.fill();
                    } else if (isRecentlyActive) {
                        // Subtle glow for recently active nodes
                        hue = 120 + (node.id * 25) % 80; // Green-cyan range for recent
                        saturation = 50 + this.params.colorIntensity * 25;
                        alpha = 0.5 + node.activation * 0.3;
                        nodeSize *= 1.1;
                    } else if (isHighlyActive) {
                        // Enhanced brightness for highly active nodes
                        saturation = 40 + this.params.colorIntensity * 30;
                        alpha = 0.4 + node.activation * 0.4;
                        nodeSize *= 1.05;
                    }
                    
                                         ctx.beginPath();
                     ctx.arc(finalX, finalY, nodeSize, 0, Math.PI * 2);
                     ctx.fillStyle = `hsla(${hue}, ${saturation}%, 65%, ${alpha})`;
                     ctx.fill();
                     
                     // Add subtle fitness indicator (small inner dot)
                     if (node.fitness !== undefined) {
                         const fitnessSize = nodeSize * 0.3 * node.fitness;
                         if (fitnessSize > 0.5) {
                             ctx.beginPath();
                             ctx.arc(finalX, finalY, fitnessSize, 0, Math.PI * 2);
                             ctx.fillStyle = `hsla(${hue + 60}, 80%, 85%, ${0.6})`;
                             ctx.fill();
                         }
                     }
                     
                     // Add generation indicator (tiny ring for newer generations)
                     if (node.generation !== undefined && node.generation > 0) {
                         const generationIntensity = Math.min(node.generation / 5, 1); // Max at generation 5
                         ctx.beginPath();
                         ctx.arc(finalX, finalY, nodeSize * 1.1, 0, Math.PI * 2);
                         ctx.strokeStyle = `hsla(280, 70%, 80%, ${0.3 * generationIntensity})`;
                         ctx.lineWidth = scale * 0.2;
                         ctx.stroke();
                     }
                    
                    // Draw memory connections as dendrites (limit on mobile for performance)
                    const maxConnections = this.isMobile ? 3 : node.connections.length;
                    const connectionsToRender = node.connections.slice(0, maxConnections);
                    
                    connectionsToRender.forEach(conn => {
                        const targetNode = nodes.find(n => n.id === conn.target);
                        if (!targetNode || targetNode.activation < targetNode.threshold) return;
                        
                        // Calculate target position using same stable distribution based on target node ID
                        const targetBaseAngle = (targetNode.id * 137.5) * (Math.PI / 180);
                        const targetMemoryLayer = Math.floor(targetNode.id / 10);
                        const targetDendriticRadius = maxRadius * (0.3 + targetMemoryLayer * 0.15);
                        const targetOrganicAngle = targetBaseAngle + Math.sin(this.smoothTime * 0.05 + targetNode.id * 0.1) * 0.1;
                        
                        const targetX = centerX + Math.cos(targetOrganicAngle) * targetDendriticRadius;
                        const targetY = centerY + Math.sin(targetOrganicAngle) * targetDendriticRadius;
                        
                        // Apply same strict containment logic to target
                        const margin = 50;
                        const nodeRadius = scale * (this.isMobile ? 2.5 : 2.0) * 1.5;
                        const minX = margin + nodeRadius;
                        const maxX = viewWidth - margin - nodeRadius;
                        const minY = margin + nodeRadius;
                        const maxY = viewHeight - margin - nodeRadius;
                        
                        // Clamp target positions strictly within bounds
                        let finalTargetX = Math.max(minX, Math.min(maxX, targetX));
                        let finalTargetY = Math.max(minY, Math.min(maxY, targetY));
                        
                        // Ensure target is within natural distribution
                        const targetDistFromCenter = Math.sqrt((finalTargetX - centerX) ** 2 + (finalTargetY - centerY) ** 2);
                        if (targetDistFromCenter > maxRadius) {
                            const scaleFactor = maxRadius / targetDistFromCenter;
                            finalTargetX = centerX + (finalTargetX - centerX) * scaleFactor;
                            finalTargetY = centerY + (finalTargetY - centerY) * scaleFactor;
                            
                            // Final safety clamp for target
                            finalTargetX = Math.max(minX, Math.min(maxX, finalTargetX));
                            finalTargetY = Math.max(minY, Math.min(maxY, finalTargetY));
                        }
                        
                        // Determine if this connection is actively being used
                        const isSourceActive = activeNodes.includes(node);
                        const isTargetActive = activeNodes.includes(targetNode);
                        const isConnectionActive = isSourceActive && isTargetActive;
                        const isRecentConnection = node.lastActivationTime && targetNode.lastActivationTime &&
                            Math.abs(node.lastActivationTime - targetNode.lastActivationTime) < 1000;
                        
                        // Draw dendritic connection
                        ctx.beginPath();
                        ctx.moveTo(finalX, finalY);
                        
                        // Create organic curved path
                        const midX = (finalX + finalTargetX) / 2 + Math.sin(this.smoothTime + conn.weight * 10) * (15 * scale);
                        const midY = (finalY + finalTargetY) / 2 + Math.cos(this.smoothTime + conn.weight * 10) * (15 * scale);
                        
                        ctx.quadraticCurveTo(midX, midY, finalTargetX, finalTargetY);
                        
                        // Enhanced connection visualization for active connections
                        const memoryStrength = (node.activation + targetNode.activation) / 2;
                        let connectionAlpha = Math.abs(conn.weight) * memoryStrength * 0.6 + 0.1;
                        let connectionHue = conn.type === 'excitatory' ? hue + 20 : hue - 20;
                        let lineWidth = scale * (this.isMobile ? 0.8 : 0.6); // Thicker connections, especially on mobile
                        
                        if (isConnectionActive) {
                            // Active connections get enhanced visuals - much slower and more subtle
                            const uniqueConnectionOffset = (node.id + targetNode.id) * 0.3;
                            const pulseIntensity = 0.3 + 0.2 * Math.sin(this.smoothTime * 1.5 + uniqueConnectionOffset);
                            connectionAlpha = 0.6 + pulseIntensity * 0.2;
                            connectionHue = 45 + (conn.weight * 50) % 30; // Golden-orange for active connections
                            lineWidth *= (1.2 + pulseIntensity * 0.2);
                            
                            // Draw gentle flowing energy effect along active connections
                            const flowPosition = (this.smoothTime * 0.5 + conn.weight * 5 + uniqueConnectionOffset) % 1;
                            const flowX = finalX + (finalTargetX - finalX) * flowPosition;
                            const flowY = finalY + (finalTargetY - finalY) * flowPosition;
                            
                            ctx.save();
                            ctx.beginPath();
                            ctx.arc(flowX, flowY, scale * 0.5, 0, Math.PI * 2);
                            ctx.fillStyle = `hsla(${connectionHue + 30}, 80%, 70%, ${0.4 + pulseIntensity * 0.2})`;
                            ctx.fill();
                            ctx.restore();
                        } else if (isRecentConnection) {
                            // Recently used connections get subtle enhancement
                            connectionAlpha *= 1.3;
                            connectionHue = 150 + (conn.weight * 40) % 60; // Green-cyan for recent
                            lineWidth *= 1.2;
                        }
                        
                        ctx.strokeStyle = `hsla(${connectionHue}, ${saturation}%, 50%, ${connectionAlpha})`;
                        ctx.lineWidth = lineWidth;
                        ctx.stroke();
                    });
                });
            }
            
            drawEvolutionIndicator(ctx, centerX, centerY, viewWidth, viewHeight) {
                if (!this.markovChain) return;
                
                const currentTime = Date.now();
                const timeSinceEvolution = currentTime - this.markovChain.lastEvolutionTime;
                const evolutionProgress = Math.min(timeSinceEvolution / this.markovChain.evolutionInterval, 1);
                
                // Show evolution cycle indicator in corner
                const indicatorSize = Math.min(viewWidth, viewHeight) * 0.05;
                const indicatorX = centerX + viewWidth * 0.4;
                const indicatorY = centerY - viewHeight * 0.4;
                
                // Evolution cycle ring
                ctx.beginPath();
                ctx.arc(indicatorX, indicatorY, indicatorSize, 0, Math.PI * 2 * evolutionProgress);
                ctx.strokeStyle = `hsla(120, 80%, 70%, 0.6)`;
                ctx.lineWidth = 3;
                ctx.stroke();
                
                // Show current node count and generation info
                const nodeCount = this.markovChain.dendriticNodes.length;
                const avgGeneration = this.markovChain.dendriticNodes.reduce((sum, node) => sum + (node.generation || 0), 0) / nodeCount;
                
                ctx.fillStyle = `hsla(120, 80%, 70%, 0.8)`;
                ctx.font = '12px monospace';
                ctx.textAlign = 'center';
                ctx.fillText(`${nodeCount}`, indicatorX, indicatorY + 4);
                
                if (avgGeneration > 0) {
                    ctx.fillStyle = `hsla(280, 70%, 80%, 0.6)`;
                    ctx.font = '10px monospace';
                    ctx.fillText(`G${avgGeneration.toFixed(1)}`, indicatorX, indicatorY + 18);
                }
            }
            
            drawStateTransitionMemory(ctx, centerX, centerY, viewWidth, viewHeight) {
                if (!this.markovChain.transitionHistory) return;
                
                const history = this.markovChain.transitionHistory.slice(-30);
                const scale = Math.min(viewWidth, viewHeight) / 800; // Same scaling as nodes
                const maxRadius = Math.min(viewWidth, viewHeight) * 0.25;
                
                for (let i = 1; i < history.length; i++) {
                    const prevState = history[i - 1];
                    const currState = history[i];
                    
                    // Convert states to contained positions
                    const prevAngle = this.stateToAngle(prevState);
                    const currAngle = this.stateToAngle(currState);
                    
                    const prevRadius = maxRadius * (0.7 + Math.sin(this.smoothTime * 0.1 + i) * 0.2);
                    const currRadius = maxRadius * (0.7 + Math.sin(this.smoothTime * 0.1 + i + 1) * 0.2);
                    
                    const prevX = centerX + Math.cos(prevAngle) * prevRadius;
                    const prevY = centerY + Math.sin(prevAngle) * prevRadius;
                    const currX = centerX + Math.cos(currAngle) * currRadius;
                    const currY = centerY + Math.sin(currAngle) * currRadius;
                    
                    // Clamp to viewport
                    const clampedPrevX = Math.max(50, Math.min(this.canvas.width - 50, prevX));
                    const clampedPrevY = Math.max(50, Math.min(this.canvas.height - 50, prevY));
                    const clampedCurrX = Math.max(50, Math.min(this.canvas.width - 50, currX));
                    const clampedCurrY = Math.max(50, Math.min(this.canvas.height - 50, currY));
                    
                    // Draw memory transition as dendritic branch
                    ctx.beginPath();
                    ctx.moveTo(clampedPrevX, clampedPrevY);
                    
                    // Create branching pattern
                    const segments = 5;
                    for (let seg = 1; seg <= segments; seg++) {
                        const t = seg / segments;
                        const x = clampedPrevX + (clampedCurrX - clampedPrevX) * t;
                        const y = clampedPrevY + (clampedCurrY - clampedPrevY) * t;
                        
                        // Add organic branching
                        const branchX = x + Math.sin(this.smoothTime * 0.5 + i + seg) * 15 * (1 - t);
                        const branchY = y + Math.cos(this.smoothTime * 0.5 + i + seg) * 15 * (1 - t);
                        
                        ctx.lineTo(branchX, branchY);
                    }
                    
                    const age = (history.length - i) / history.length;
                    const hue = 180 + (i * 15) % 60; // Cyan-blue range only
                    const alpha = age * 0.4 + 0.1;
                    
                    ctx.strokeStyle = `hsla(${hue}, 40%, 50%, ${alpha})`;
                    ctx.lineWidth = scale * 0.3; // Fixed line width
                    ctx.stroke();
                }
            }
            
            drawParameterMemoryStructure(ctx, centerX, centerY, viewWidth, viewHeight) {
                const paramKeys = Object.keys(this.params);
                const numRings = 3;
                const maxRadius = Math.min(viewWidth, viewHeight) * 0.45;
                
                for (let ring = 0; ring < numRings; ring++) {
                    const ringRadius = maxRadius * (0.2 + ring * 0.25);
                    const paramsInRing = Math.ceil(paramKeys.length / numRings);
                    const startIndex = ring * paramsInRing;
                    const endIndex = Math.min(startIndex + paramsInRing, paramKeys.length);
                    
                    for (let i = startIndex; i < endIndex; i++) {
                        const paramKey = paramKeys[i];
                        const paramValue = this.params[paramKey];
                        
                        const angleStep = (Math.PI * 2) / (endIndex - startIndex);
                        const angle = (i - startIndex) * angleStep + this.smoothTime * 0.02 * (ring + 1);
                        
                        const x = centerX + Math.cos(angle) * ringRadius;
                        const y = centerY + Math.sin(angle) * ringRadius;
                        
                        // Clamp to viewport
                        const clampedX = Math.max(50, Math.min(this.canvas.width - 50, x));
                        const clampedY = Math.max(50, Math.min(this.canvas.height - 50, y));
                        
                        // Draw parameter memory node - consistent size
                        const nodeSize = scale * 0.8; // Fixed size
                        const hue = 220 + (i * 10 + ring * 30) % 80; // Purple-blue range only
                        const saturation = 25 + this.params.colorIntensity * 15;
                        const alpha = 0.2 + paramValue * 0.6; // Only alpha changes with parameter value
                        
                        ctx.beginPath();
                        ctx.arc(clampedX, clampedY, nodeSize, 0, Math.PI * 2);
                        ctx.fillStyle = `hsla(${hue}, ${saturation}%, 70%, ${alpha})`;
                        ctx.fill();
                        
                        // Draw dendritic branches from center
                        const branchSegments = Math.floor(3 + paramValue * 5);
                        for (let seg = 0; seg < branchSegments; seg++) {
                            const segmentT = seg / branchSegments;
                            const branchAngle = angle + (seg - branchSegments/2) * 0.3;
                            const branchLength = ringRadius * 0.3 * paramValue;
                            
                            const branchX = clampedX + Math.cos(branchAngle) * branchLength * segmentT;
                            const branchY = clampedY + Math.sin(branchAngle) * branchLength * segmentT;
                            
                            ctx.beginPath();
                            ctx.moveTo(clampedX, clampedY);
                            ctx.lineTo(branchX, branchY);
                            ctx.strokeStyle = `hsla(${hue}, ${saturation * 0.8}%, 45%, ${alpha * 0.4})`;
                            ctx.lineWidth = scale * 0.25; // Fixed line width
                            ctx.stroke();
                        }
                    }
                }
            }
            
            // Legacy method - now replaced by renderMemoryObjects
            renderBeautiful2D() {
                 // Get 2D context from canvas (not WebGL)
                 const canvas2d = document.createElement('canvas');
                 canvas2d.width = this.canvas.width;
                 canvas2d.height = this.canvas.height;
                 canvas2d.style.position = 'absolute';
                 canvas2d.style.top = '0';
                 canvas2d.style.left = '0';
                 canvas2d.style.zIndex = '2';
                 canvas2d.style.pointerEvents = 'none';
                 canvas2d.id = 'visual-canvas-2d';
                 
                 // Replace or add the 2D canvas
                 let existingCanvas = document.getElementById('visual-canvas-2d');
                 if (existingCanvas) {
                     existingCanvas.parentNode.replaceChild(canvas2d, existingCanvas);
                 } else {
                     this.canvas.parentNode.appendChild(canvas2d);
                 }
                 
                 const ctx = canvas2d.getContext('2d');
                 if (!ctx) return;
                 
                 // Clear with gentle fade instead of hard clear
                 ctx.fillStyle = 'rgba(2, 2, 8, 0.05)';
                 ctx.fillRect(0, 0, canvas2d.width, canvas2d.height);
                 
                 const centerX = canvas2d.width / 2;
                 const centerY = canvas2d.height / 2;
                 
                 // Draw ONLY dendritic network driven by Markov chains
                 this.drawMarkovDrivenVisuals(ctx, centerX, centerY);
             }
             
             drawMarkovDrivenVisuals(ctx, centerX, centerY) {
                 if (!this.markovChain) return;
                 
                 const visualParams = this.markovChain.getVisualParameters();
                 const audioParams = this.markovChain.getAudioParameters();
                 
                 // Draw ALL dendritic patterns simultaneously, layered and algorithm-driven
                 this.drawDendriticSpiral(ctx, centerX, centerY, visualParams);
                 this.drawDendriticMandala(ctx, centerX, centerY, visualParams);
                 this.drawDendriticWaves(ctx, centerX, centerY, visualParams);
                 this.drawDendriticParticles(ctx, centerX, centerY, visualParams);
                 this.drawDendriticGeometry(ctx, centerX, centerY, visualParams);
                 
                 // Draw dendritic network connections
                 this.drawDendriticNetwork(ctx, centerX, centerY, visualParams);
                 
                 // Draw parameter-driven dendritic structures
                 this.drawParameterDendrites(ctx, centerX, centerY);
                 
                 // Draw Markov state transitions as dendrites
                 this.drawMarkovStateDendrites(ctx, centerX, centerY);
             }
             
             drawParameterDendrites(ctx, centerX, centerY) {
                 // Create dendritic patterns based on all interactive parameters
                 const paramKeys = Object.keys(this.params);
                 const numBranches = Math.floor(paramKeys.length / 3);
                 
                 for (let i = 0; i < numBranches; i++) {
                     const paramIndex = i * 3;
                     if (paramIndex >= paramKeys.length) break;
                     
                     const param1 = this.params[paramKeys[paramIndex]] || 0.5;
                     const param2 = this.params[paramKeys[paramIndex + 1]] || 0.5;
                     const param3 = this.params[paramKeys[paramIndex + 2]] || 0.5;
                     
                     const angle = (i / numBranches) * Math.PI * 2;
                     const baseRadius = 100 + param1 * 150;
                     
                     // Draw main branch
                     const branchLength = param2 * 200;
                     const segments = Math.floor(5 + param3 * 10);
                     
                     ctx.beginPath();
                     for (let seg = 0; seg <= segments; seg++) {
                         const t = seg / segments;
                         const segmentRadius = baseRadius + t * branchLength;
                         const segmentAngle = angle + Math.sin(t * Math.PI * 4 + this.smoothTime * this.params.animationSpeed) * param3 * 0.5;
                         
                         const x = centerX + Math.cos(segmentAngle) * segmentRadius;
                         const y = centerY + Math.sin(segmentAngle) * segmentRadius;
                         
                         if (seg === 0) {
                             ctx.moveTo(x, y);
                         } else {
                             ctx.lineTo(x, y);
                         }
                         
                         // Add sub-branches at certain points
                         if (seg % 3 === 0 && seg > 0) {
                             const subBranchAngle = segmentAngle + (Math.random() - 0.5) * Math.PI * 0.5;
                             const subBranchLength = branchLength * 0.3 * param1;
                             
                             const subX = x + Math.cos(subBranchAngle) * subBranchLength;
                             const subY = y + Math.sin(subBranchAngle) * subBranchLength;
                             
                             ctx.moveTo(x, y);
                             ctx.lineTo(subX, subY);
                             ctx.moveTo(x, y);
                         }
                     }
                     
                     const hue = (i * 60 + this.smoothTime * 30 * this.params.animationSpeed) % 360;
                     const saturation = 70 + this.params.colorIntensity * 25;
                     const alpha = (0.4 + this.smoothMusicEnergy.current * 0.4) * this.params.colorIntensity;
                     
                     ctx.strokeStyle = `hsla(${hue}, ${saturation}%, 65%, ${alpha})`;
                     ctx.lineWidth = 1 + param1 * 3 + this.params.pulseStrength * 2;
                     ctx.stroke();
                 }
             }
             
             drawMarkovStateDendrites(ctx, centerX, centerY) {
                 if (!this.markovChain || !this.markovChain.transitionHistory) return;
                 
                 const history = this.markovChain.transitionHistory.slice(-20); // Last 20 transitions
                 const radius = 200;
                 
                 for (let i = 1; i < history.length; i++) {
                     const prevState = history[i - 1];
                     const currState = history[i];
                     
                     // Convert state names to angles
                     const prevAngle = this.stateToAngle(prevState);
                     const currAngle = this.stateToAngle(currState);
                     
                     const prevX = centerX + Math.cos(prevAngle) * radius;
                     const prevY = centerY + Math.sin(prevAngle) * radius;
                     const currX = centerX + Math.cos(currAngle) * radius;
                     const currY = centerY + Math.sin(currAngle) * radius;
                     
                     // Draw dendritic connection
                     ctx.beginPath();
                     
                     // Create curved dendritic path
                     const midX = (prevX + currX) / 2 + Math.sin(this.smoothTime + i) * 30;
                     const midY = (prevY + currY) / 2 + Math.cos(this.smoothTime + i) * 30;
                     
                     ctx.moveTo(prevX, prevY);
                     ctx.quadraticCurveTo(midX, midY, currX, currY);
                     
                     const age = (history.length - i) / history.length;
                     const hue = (i * 45 + this.smoothTime * 20) % 360;
                     const alpha = age * 0.6 * this.params.colorIntensity;
                     
                     ctx.strokeStyle = `hsla(${hue}, 80%, 70%, ${alpha})`;
                     ctx.lineWidth = 1 + age * 2 + this.params.transitionRate * 2;
                     ctx.stroke();
                 }
             }
             
             stateToAngle(state) {
                 // Convert state string to consistent angle
                 let hash = 0;
                 for (let i = 0; i < state.length; i++) {
                     hash = ((hash << 5) - hash + state.charCodeAt(i)) & 0xffffffff;
                 }
                 return (Math.abs(hash) / 0xffffffff) * Math.PI * 2;
             }
             
             drawDendriticSpiral(ctx, centerX, centerY, params) {
                 const branches = 8 + Math.floor(params.complexity * 12);
                 const baseRadius = 30 + params.intensity * 80;
                 
                 for (let i = 0; i < branches; i++) {
                     const angle = (i / branches) * Math.PI * 2 + this.smoothTime * 0.1 * params.dendriticInfluence;
                     const spiralTurns = 3 + params.complexity * 2;
                     
                     ctx.beginPath();
                     for (let t = 0; t < spiralTurns; t += 0.1) {
                         const spiralAngle = angle + t * Math.PI * 2;
                         const radius = baseRadius * (1 - t / spiralTurns) * (1 + Math.sin(this.smoothTime * 2 + i) * 0.2);
                         
                         const x = centerX + Math.cos(spiralAngle) * radius;
                         const y = centerY + Math.sin(spiralAngle) * radius;
                         
                         if (t === 0) {
                             ctx.moveTo(x, y);
                         } else {
                             ctx.lineTo(x, y);
                         }
                     }
                     
                     const hue = (this.smoothTime * 30 + i * 45 + params.dendriticInfluence * 180) % 360;
                     const alpha = 0.3 + params.intensity * 0.5;
                     
                     ctx.strokeStyle = `hsla(${hue}, 70%, 60%, ${alpha})`;
                     ctx.lineWidth = 2 + params.intensity * 3;
                     ctx.stroke();
                 }
             }
             
             drawDendriticMandala(ctx, centerX, centerY, params) {
                 const petals = 6 + Math.floor(params.complexity * 12);
                 const layers = 3 + Math.floor(params.intensity * 3);
                 
                 for (let layer = 0; layer < layers; layer++) {
                     const layerRadius = (30 + layer * 25) * (1 + params.dendriticInfluence);
                     
                     for (let i = 0; i < petals; i++) {
                         const angle = (i / petals) * Math.PI * 2 + this.smoothTime * 0.05 * (layer + 1);
                         const petalSize = layerRadius * 0.3 * (1 + Math.sin(this.smoothTime * 3 + i + layer) * 0.3);
                         
                         const x = centerX + Math.cos(angle) * layerRadius;
                         const y = centerY + Math.sin(angle) * layerRadius;
                         
                         ctx.save();
                         ctx.translate(x, y);
                         ctx.rotate(angle + Math.PI / 2);
                         
                         ctx.beginPath();
                         ctx.ellipse(0, 0, petalSize * 0.4, petalSize, 0, 0, Math.PI * 2);
                         
                         const hue = (this.smoothTime * 20 + i * 30 + layer * 60 + params.dendriticInfluence * 120) % 360;
                         const alpha = (0.2 + params.intensity * 0.3) / (layer + 1);
                         
                         ctx.fillStyle = `hsla(${hue}, 80%, 65%, ${alpha})`;
                         ctx.fill();
                         
                         ctx.restore();
                     }
                 }
             }
             
             drawDendriticWaves(ctx, centerX, centerY, params) {
                 const waveCount = 4 + Math.floor(params.complexity * 6);
                 
                 for (let wave = 0; wave < waveCount; wave++) {
                     ctx.beginPath();
                     
                     const amplitude = (40 + params.intensity * 60) * (1 + params.dendriticInfluence * 0.5);
                     const frequency = (0.008 + wave * 0.003) * (1 + params.complexity);
                     const phase = this.smoothTime * 0.3 + wave * Math.PI / 3;
                     const yOffset = centerY + (wave - waveCount / 2) * 30;
                     
                     for (let x = 0; x < ctx.canvas.width; x += 3) {
                         const y = yOffset + Math.sin(x * frequency + phase) * amplitude;
                         
                         if (x === 0) {
                             ctx.moveTo(x, y);
                         } else {
                             ctx.lineTo(x, y);
                         }
                     }
                     
                     const hue = (this.smoothTime * 25 + wave * 90 + params.dendriticInfluence * 150) % 360;
                     const alpha = 0.25 + params.intensity * 0.4;
                     
                     ctx.strokeStyle = `hsla(${hue}, 75%, 55%, ${alpha})`;
                     ctx.lineWidth = 2 + params.intensity * 4;
                     ctx.stroke();
                 }
             }
             
             drawDendriticParticles(ctx, centerX, centerY, params) {
                 const particleCount = Math.floor(20 + params.complexity * 30);
                 
                 for (let i = 0; i < particleCount; i++) {
                     const angle = (i / particleCount) * Math.PI * 2 + this.smoothTime * 0.2;
                     const distance = (50 + Math.random() * 100) * (1 + params.dendriticInfluence);
                     const size = (3 + params.intensity * 8) * (0.5 + Math.random() * 0.5);
                     
                     const x = centerX + Math.cos(angle) * distance + Math.sin(this.smoothTime * 4 + i) * 20;
                     const y = centerY + Math.sin(angle) * distance + Math.cos(this.smoothTime * 3 + i) * 15;
                     
                     const hue = (this.smoothTime * 40 + i * 15 + params.dendriticInfluence * 200) % 360;
                     const alpha = 0.4 + params.intensity * 0.4;
                     
                     ctx.beginPath();
                     ctx.arc(x, y, size, 0, Math.PI * 2);
                     ctx.fillStyle = `hsla(${hue}, 70%, 60%, ${alpha})`;
                     ctx.fill();
                     
                     // Add dendritic connections between nearby particles
                     if (i > 0 && Math.random() < params.complexity) {
                         const prevAngle = ((i - 1) / particleCount) * Math.PI * 2 + this.smoothTime * 0.2;
                         const prevDistance = (50 + Math.random() * 100) * (1 + params.dendriticInfluence);
                         const prevX = centerX + Math.cos(prevAngle) * prevDistance + Math.sin(this.smoothTime * 4 + i - 1) * 20;
                         const prevY = centerY + Math.sin(prevAngle) * prevDistance + Math.cos(this.smoothTime * 3 + i - 1) * 15;
                         
                         ctx.beginPath();
                         ctx.moveTo(x, y);
                         ctx.lineTo(prevX, prevY);
                         ctx.strokeStyle = `hsla(${hue}, 50%, 50%, ${alpha * 0.5})`;
                         ctx.lineWidth = 1;
                         ctx.stroke();
                     }
                 }
             }
             
             drawDendriticGeometry(ctx, centerX, centerY, params) {
                 const sides = 3 + Math.floor(params.complexity * 5);
                 const layers = 2 + Math.floor(params.intensity * 3);
                 
                 for (let layer = 0; layer < layers; layer++) {
                     const radius = (40 + layer * 30) * (1 + params.dendriticInfluence * 0.5);
                     const rotation = this.smoothTime * 0.1 * (layer + 1) + params.dendriticInfluence * Math.PI;
                     
                     ctx.save();
                     ctx.translate(centerX, centerY);
                     ctx.rotate(rotation);
                     
                     ctx.beginPath();
                     for (let i = 0; i <= sides; i++) {
                         const angle = (i / sides) * Math.PI * 2;
                         const x = Math.cos(angle) * radius;
                         const y = Math.sin(angle) * radius;
                         
                         if (i === 0) {
                             ctx.moveTo(x, y);
                         } else {
                             ctx.lineTo(x, y);
                         }
                     }
                     
                     const hue = (this.smoothTime * 35 + layer * 120 + params.dendriticInfluence * 180) % 360;
                     const alpha = (0.3 + params.intensity * 0.4) / (layer + 1);
                     
                     ctx.strokeStyle = `hsla(${hue}, 75%, 55%, ${alpha})`;
                     ctx.lineWidth = 2 + params.intensity * 2;
                     ctx.stroke();
                     
                     ctx.restore();
                 }
             }
             
             drawDendriticNetwork(ctx, centerX, centerY, params) {
                 if (!this.markovChain || !this.markovChain.dendriticNodes) return;
                 
                 const allNodes = this.markovChain.dendriticNodes;
                 const activeNodes = allNodes.filter(node => node.activation > node.threshold);
                 const currentTime = Date.now();
                 
                 // Get jazz conversation context if available
                 const jazzConversation = this.audioEngine?.jazzConversation;
                 const jazzPhase = jazzConversation?.conversationPhase || 'statement';
                 const improvisationLevel = jazzConversation?.improvisationLevel || 0.3;
                 const memoryInfluence = jazzConversation?.memoryInfluence || 0.5;
                 
                 // Jazz phase colors and behaviors
                 const jazzPhaseColors = {
                     'statement': { hue: 220, intensity: 0.9, pulse: 1.0, name: 'STATEMENT' },      // Blue - clear statement
                     'response': { hue: 120, intensity: 1.0, pulse: 1.2, name: 'RESPONSE' },       // Green - answering
                     'development': { hue: 30, intensity: 1.2, pulse: 1.8, name: 'DEVELOPMENT' },     // Orange - exploring
                     'resolution': { hue: 280, intensity: 0.8, pulse: 0.9, name: 'RESOLUTION' }      // Purple - resolving
                 };
                 
                 const phaseInfo = jazzPhaseColors[jazzPhase];
                 const phaseHue = phaseInfo.hue;
                 const phaseIntensity = phaseInfo.intensity;
                 const phasePulse = phaseInfo.pulse;
                 
                 // Clear background for better visibility
                 ctx.save();
                 ctx.globalAlpha = 0.1;
                 ctx.fillStyle = '#000000';
                 ctx.fillRect(centerX - 300, centerY - 300, 600, 600);
                 ctx.restore();
                 
                 // Draw ALL nodes (active and inactive) to show the full network with much more dynamic behavior
                 allNodes.forEach((node, index) => {
                     const isActive = node.activation > node.threshold;
                     
                     // Much more dynamic angle calculation based on jazz phase and evolution
                     let angle = (index / allNodes.length) * Math.PI * 2;
                     
                     // Jazz phase dramatically affects positioning
                     switch (jazzPhase) {
                         case 'statement':
                             // Stable, ordered positioning
                             angle += Math.sin(this.smoothTime * 0.5) * 0.1;
                             break;
                         case 'response':
                             // Responsive movement - nodes "answer" each other
                             angle += Math.sin(this.smoothTime * 1.5 + node.id) * 0.3;
                             break;
                         case 'development':
                             // Chaotic, exploratory movement
                             angle += Math.sin(this.smoothTime * 3 + node.id) * 0.8 * improvisationLevel;
                             angle += Math.cos(this.smoothTime * 2 + node.musicalNote) * 0.5;
                             break;
                         case 'resolution':
                             // Gentle return to order
                             angle += Math.sin(this.smoothTime * 0.8 + node.id) * 0.2;
                             break;
                     }
                     
                     // Evolution cycle affects the overall rotation
                     angle += (evolutionCycle * 0.1) + (this.smoothTime * 0.1);
                     
                     // Much more dramatic distance variations
                     const baseDistance = isActive ? (100 + node.activation * 100) : (60 + node.activation * 40);
                     
                     // Jazz phase affects distance dramatically
                     let phaseDistanceModifier = 0;
                     switch (jazzPhase) {
                         case 'statement':
                             phaseDistanceModifier = 20;
                             break;
                         case 'response':
                             phaseDistanceModifier = 40 + Math.sin(this.smoothTime * 2 + node.id) * 20;
                             break;
                         case 'development':
                             phaseDistanceModifier = 60 + Math.sin(this.smoothTime * 4 + node.id) * 50 * improvisationLevel;
                             break;
                         case 'resolution':
                             phaseDistanceModifier = 30 + Math.sin(this.smoothTime * 1 + node.id) * 15;
                             break;
                     }
                     
                     // Musical nodes get special positioning
                     const isMusicallyActive = node.isCurrentlyGeneratingMusic || 
                         (currentTime - (node.lastMusicGenerationTime || 0)) < 2000;
                     if (isMusicallyActive) {
                         phaseDistanceModifier += 30 + Math.sin(this.smoothTime * 6) * 20;
                     }
                     
                     // Generation affects positioning - evolved nodes move differently
                     const generationEffect = (node.generation || 0) * 10;
                     
                     const distance = baseDistance + phaseDistanceModifier + generationEffect;
                     
                     const x = centerX + Math.cos(angle) * distance;
                     const y = centerY + Math.sin(angle) * distance;
                     
                     // Much more dynamic node appearance
                     let baseSize = isActive ? (6 + node.activation * 15) : 2;
                     
                     // Jazz phase dramatically affects size
                     let phaseSizeModifier = 0;
                     switch (jazzPhase) {
                         case 'statement':
                             phaseSizeModifier = 2;
                             break;
                         case 'response':
                             phaseSizeModifier = 4 + Math.sin(this.smoothTime * 3 + node.id) * 3;
                             break;
                         case 'development':
                             phaseSizeModifier = 6 + Math.sin(this.smoothTime * 5 + node.id) * 8 * improvisationLevel;
                             break;
                         case 'resolution':
                             phaseSizeModifier = 3 + Math.sin(this.smoothTime * 2 + node.id) * 2;
                             break;
                     }
                     
                     // Generation affects size - evolved nodes are bigger
                     const generationSizeBonus = (node.generation || 0) * 2;
                     
                     const nodeSize = baseSize + phaseSizeModifier + generationSizeBonus;
                     
                     // Much more dynamic color system
                     let nodeHue = phaseHue;
                     
                     // Musical note creates color variation
                     if (node.musicalNote !== undefined) {
                         const musicalHue = (node.musicalNote * 30 + this.smoothTime * 10) % 360;
                         nodeHue = (phaseHue * (1 - memoryInfluence) + musicalHue * memoryInfluence) % 360;
                     }
                     
                     // Evolution cycle affects hue
                     nodeHue = (nodeHue + evolutionCycle * 5) % 360;
                     
                     // Jazz phase affects saturation and lightness
                     let saturation = 80;
                     let lightness = 60;
                     
                     switch (jazzPhase) {
                         case 'statement':
                             saturation = 70;
                             lightness = 50;
                             break;
                         case 'response':
                             saturation = 85 + Math.sin(this.smoothTime * 2) * 10;
                             lightness = 60 + Math.sin(this.smoothTime * 2.5) * 10;
                             break;
                         case 'development':
                             saturation = 90 + Math.sin(this.smoothTime * 4 + node.id) * 10;
                             lightness = 70 + Math.sin(this.smoothTime * 3 + node.id) * 15;
                             break;
                         case 'resolution':
                             saturation = 75;
                             lightness = 55;
                             break;
                     }
                     
                     const alpha = isActive ? 
                         (0.6 + node.activation * 0.4 + Math.sin(this.smoothTime * 2 + node.id) * 0.2) * phaseIntensity : 
                         0.15;
                     
                     // Special highlighting for nodes currently generating music
                     const isGeneratingMusic = node.isCurrentlyGeneratingMusic || 
                         (currentTime - (node.lastMusicGenerationTime || 0)) < 2000;
                     
                     if (isGeneratingMusic) {
                         // Musical nodes get multiple glowing rings
                         for (let ring = 1; ring <= 3; ring++) {
                             const glowSize = nodeSize + (ring * 8);
                             const glowAlpha = (0.4 / ring) * Math.sin(this.smoothTime * (3 + ring)) * phasePulse;
                             
                             ctx.beginPath();
                             ctx.arc(x, y, glowSize, 0, Math.PI * 2);
                             ctx.fillStyle = `hsla(${nodeHue}, 90%, 80%, ${Math.abs(glowAlpha)})`;
                             ctx.fill();
                         }
                         
                         // Add musical note indicator
                         ctx.fillStyle = `hsla(${nodeHue}, 100%, 90%, 0.9)`;
                         ctx.font = 'bold 10px monospace';
                         ctx.textAlign = 'center';
                         ctx.fillText('♪', x, y + 3);
                     }
                     
                     // Draw main node with dynamic colors
                     ctx.beginPath();
                     ctx.arc(x, y, nodeSize, 0, Math.PI * 2);
                     ctx.fillStyle = `hsla(${nodeHue}, ${saturation}%, ${lightness}%, ${alpha})`;
                     ctx.fill();
                     
                     // Dynamic border for active nodes
                     if (isActive) {
                         ctx.beginPath();
                         ctx.arc(x, y, nodeSize, 0, Math.PI * 2);
                         const borderLightness = Math.min(90, lightness + 20);
                         ctx.strokeStyle = `hsla(${nodeHue}, ${Math.min(100, saturation + 10)}%, ${borderLightness}%, 0.9)`;
                         ctx.lineWidth = jazzPhase === 'development' ? 3 : 2;
                         ctx.stroke();
                     }
                     
                     // Generation indicators - make them much more visible
                     if (node.generation && node.generation > 0) {
                         // Multiple rings for higher generations
                         for (let gen = 1; gen <= Math.min(node.generation, 5); gen++) {
                             const genRing = nodeSize + (gen * 3);
                             ctx.beginPath();
                             ctx.arc(x, y, genRing, 0, Math.PI * 2);
                             ctx.strokeStyle = `hsla(${nodeHue + (gen * 30)}, 80%, 70%, ${0.6 / gen})`;
                             ctx.lineWidth = 2;
                             ctx.stroke();
                         }
                         
                         // Generation number
                         if (node.generation > 1) {
                             ctx.fillStyle = `hsla(${nodeHue}, 100%, 90%, 0.9)`;
                             ctx.font = 'bold 8px monospace';
                             ctx.textAlign = 'center';
                             ctx.fillText(node.generation.toString(), x, y - nodeSize - 8);
                         }
                     }
                     
                     // Fitness indicator
                     if (isActive && node.fitness > 0.7) {
                         ctx.fillStyle = `hsla(60, 100%, 80%, 0.8)`;
                         ctx.font = 'bold 12px monospace';
                         ctx.textAlign = 'center';
                         ctx.fillText('★', x + nodeSize + 5, y + 3);
                     }
                     
                     // Draw connections with enhanced visibility
                     if (isActive) {
                     node.connections.forEach(conn => {
                             const targetNode = allNodes.find(n => n.id === conn.target);
                             if (targetNode && targetNode.activation > targetNode.threshold) {
                                 const targetIndex = allNodes.indexOf(targetNode);
                                 const targetAngle = (targetIndex / allNodes.length) * Math.PI * 2;
                                 
                                 const targetIsActive = targetNode.activation > targetNode.threshold;
                                 const targetBaseDistance = targetIsActive ? 120 : 80;
                                 const targetActivationDistance = targetNode.activation * 80;
                                 const targetJazzVariation = jazzPhase === 'development' ? 
                                     Math.sin(this.smoothTime * 2 + targetNode.id) * 30 * improvisationLevel : 0;
                                 const targetDistance = targetBaseDistance + targetActivationDistance + targetJazzVariation;
                             
                             const targetX = centerX + Math.cos(targetAngle) * targetDistance;
                             const targetY = centerY + Math.sin(targetAngle) * targetDistance;
                                 
                                 // Enhanced connection appearance
                                 const connectionAlpha = Math.abs(conn.weight) * 0.6;
                                 
                                 // Musical connections get special treatment
                                 let connectionHue = conn.type === 'excitatory' ? 120 : 0;
                                 if (conn.musicalStrength !== undefined && conn.musicalStrength > 0.5) {
                                     // Musical connections take on jazz phase colors
                                     connectionHue = (phaseHue + 180) % 360; // Complementary color
                                 }
                                 
                                 // Jazz conversation influences connection behavior
                                 let lineWidth = 2 + Math.abs(conn.weight) * 3;
                                 if (jazzPhase === 'development') {
                                     // More dynamic connections during development
                                     lineWidth += Math.sin(this.smoothTime * 2 + conn.target) * 2 * improvisationLevel;
                                 }
                             
                             ctx.beginPath();
                             ctx.moveTo(x, y);
                                 
                                 // Curved connections during jazz development phase
                                 if (jazzPhase === 'development' && improvisationLevel > 0.5) {
                                     const midX = (x + targetX) / 2;
                                     const midY = (y + targetY) / 2;
                                     const curveOffset = Math.sin(this.smoothTime + conn.target) * 40 * improvisationLevel;
                                     
                                     ctx.quadraticCurveTo(
                                         midX + curveOffset, 
                                         midY + curveOffset, 
                                         targetX, 
                                         targetY
                                     );
                                 } else {
                                     ctx.lineTo(targetX, targetY);
                                 }
                                 
                                 ctx.strokeStyle = `hsla(${connectionHue}, 80%, 60%, ${connectionAlpha})`;
                                 ctx.lineWidth = Math.max(1, lineWidth);
                             ctx.stroke();
                                 
                                 // Add connection strength indicator for strong musical connections
                                 if (conn.musicalStrength > 0.7) {
                                     const midX = (x + targetX) / 2;
                                     const midY = (y + targetY) / 2;
                                     ctx.fillStyle = `hsla(${connectionHue}, 100%, 80%, 0.8)`;
                                     ctx.font = 'bold 8px monospace';
                                     ctx.textAlign = 'center';
                                     ctx.fillText('♫', midX, midY);
                                 }
                             }
                         });
                     }
                 });
                 
                 // Draw enhanced jazz conversation phase indicator in the center
                 if (jazzConversation) {
                     const phaseRadius = 40;
                     const phaseProgress = (currentTime - jazzConversation.phaseStartTime) / jazzConversation.phaseDuration;
                     
                     // Phase background with glow
                     ctx.beginPath();
                     ctx.arc(centerX, centerY, phaseRadius + 10, 0, Math.PI * 2);
                     ctx.fillStyle = `hsla(${phaseHue}, 40%, 20%, 0.3)`;
                     ctx.fill();
                     
                     // Phase background
                     ctx.beginPath();
                     ctx.arc(centerX, centerY, phaseRadius, 0, Math.PI * 2);
                     ctx.fillStyle = `hsla(${phaseHue}, 50%, 30%, 0.7)`;
                     ctx.fill();
                     
                     // Phase progress arc
                     ctx.beginPath();
                     ctx.arc(centerX, centerY, phaseRadius - 3, -Math.PI/2, -Math.PI/2 + Math.PI * 2 * phaseProgress);
                     ctx.strokeStyle = `hsla(${phaseHue}, 90%, 70%, 0.9)`;
                     ctx.lineWidth = 6;
                     ctx.stroke();
                     
                     // Phase name
                     ctx.fillStyle = `hsla(${phaseHue}, 100%, 90%, 1.0)`;
                     ctx.font = 'bold 12px monospace';
                     ctx.textAlign = 'center';
                     ctx.fillText(phaseInfo.name, centerX, centerY - 5);
                     
                     // Improvisation level indicator
                     ctx.fillStyle = `hsla(${phaseHue}, 80%, 80%, 0.8)`;
                     ctx.font = '10px monospace';
                     ctx.fillText(`IMPROV: ${Math.round(improvisationLevel * 100)}%`, centerX, centerY + 8);
                     
                     // Memory influence indicator
                     ctx.fillStyle = `hsla(${phaseHue}, 60%, 70%, 0.8)`;
                     ctx.font = '8px monospace';
                     ctx.fillText(`MEM: ${Math.round(memoryInfluence * 100)}%`, centerX, centerY + 18);
                 }
                 
                 // Add evolution cycle indicator - mobile responsive positioning using actual canvas bounds
                 const evolutionCycle = this.markovChain.evolutionCycle;
                 const evolutionProgress = (currentTime - this.markovChain.lastEvolutionTime) / this.markovChain.evolutionInterval;
                 
                 // Check if mobile/small screen
                 const canvasWidth = this.canvas.width;
                 const canvasHeight = this.canvas.height;
                 const isMobile = canvasWidth < 800;
                 
                 // Evolution indicator - positioned within actual canvas bounds
                 const evolX = isMobile ? canvasWidth / 2 : canvasWidth - 120;
                 const evolY = isMobile ? canvasHeight - 80 : 40;
                 
                 ctx.fillStyle = `hsla(300, 90%, 80%, 1.0)`;
                 ctx.font = isMobile ? 'bold 11px monospace' : 'bold 14px monospace';
                 ctx.textAlign = 'center';
                 ctx.fillText(`EVOLUTION: ${evolutionCycle}`, evolX, evolY);
                 
                 // Evolution progress bar
                 const barWidth = isMobile ? 100 : 120;
                 const barHeight = isMobile ? 8 : 10;
                 ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
                 ctx.fillRect(evolX - barWidth/2, evolY + 8, barWidth, barHeight);
                 
                 ctx.fillStyle = `hsla(300, 100%, 80%, 1.0)`;
                 ctx.fillRect(evolX - barWidth/2, evolY + 8, barWidth * evolutionProgress, barHeight);
                 
                 // Network stats - positioned within canvas bounds
                 const activeCount = activeNodes.length;
                 const totalCount = allNodes.length;
                 const avgGeneration = allNodes.reduce((sum, node) => sum + (node.generation || 0), 0) / totalCount;
                 const musicalCount = allNodes.filter(n => (currentTime - (n.lastMusicGenerationTime || 0)) < 2000).length;
                 
                 // Position stats within canvas bounds
                 const statsX = isMobile ? 10 : 20;
                 const statsY = isMobile ? canvasHeight - 60 : 40;
                 const fontSize = isMobile ? '11px' : '13px';
                 const lineSpacing = isMobile ? 14 : 18;
                 
                 // Add background for better visibility
                 ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                 const bgWidth = isMobile ? 140 : 180;
                 const bgHeight = isMobile ? 50 : 60;
                 ctx.fillRect(statsX - 5, statsY - 15, bgWidth, bgHeight);
                 
                 ctx.fillStyle = `hsla(180, 90%, 80%, 1.0)`;
                 ctx.font = 'bold ' + fontSize + ' monospace';
                 ctx.textAlign = 'left';
                 
                 if (isMobile) {
                     // Compact mobile display
                     ctx.fillText(`NODES: ${activeCount}/${totalCount}`, statsX, statsY);
                     ctx.fillText(`GEN: ${avgGeneration.toFixed(1)} | MUSIC: ${musicalCount}`, statsX, statsY + lineSpacing);
                 } else {
                     // Full desktop display
                     ctx.fillText(`ACTIVE NODES: ${activeCount}/${totalCount}`, statsX, statsY);
                     ctx.fillText(`AVG GENERATION: ${avgGeneration.toFixed(1)}`, statsX, statsY + lineSpacing);
                     ctx.fillText(`MUSICAL NODES: ${musicalCount}`, statsX, statsY + lineSpacing * 2);
                 }
             }
            
            
            
            
            
            
            
            renderWaveform() {
                const canvas = document.getElementById('waveform-canvas');
                const ctx = canvas.getContext('2d');
                
                canvas.width = window.innerWidth;
                canvas.height = 100;
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Draw waveform based on audio data
                if (this.audioEngine && this.audioEngine.analyser) {
                    const bufferLength = this.audioEngine.analyser.frequencyBinCount;
                    const dataArray = new Uint8Array(bufferLength);
                    this.audioEngine.analyser.getByteFrequencyData(dataArray);
                    
                    const barWidth = canvas.width / bufferLength * 2;
                    let x = 0;
                    
                    for (let i = 0; i < bufferLength; i++) {
                        const barHeight = (dataArray[i] / 255) * canvas.height;
                        
                        const hue = (i / bufferLength * 360 + this.smoothTime * 30) % 360;
                        const alpha = 0.3 + this.smoothMusicEnergy.current * 0.4;
                        
                        ctx.fillStyle = `hsla(${hue}, 70%, 60%, ${alpha})`;
                        ctx.fillRect(x, canvas.height - barHeight, barWidth, barHeight);
                        
                        x += barWidth;
                    }
                }
            }
            
            createViewMatrix() {
                // Camera positioned to see the large dendrite structure
                const baseDistance = 150; // Much farther back to see the large structure
                const musicDistance = this.smoothMusicEnergy.current * 30;
                const distance = baseDistance + musicDistance;
                
                // Slower, more visible rotation
                const elevation = Math.sin(this.smoothTime * 0.1) * 0.4 + 0.3;
                const azimuth = this.smoothTime * 0.03;
                
                const eye = [
                    distance * Math.cos(elevation) * Math.sin(azimuth),
                    distance * Math.sin(elevation) + 20,
                    distance * Math.cos(elevation) * Math.cos(azimuth)
                ];
                
                return this.lookAt(eye, [0, 0, 0], [0, 1, 0]);
            }
            
            createProjectionMatrix() {
                const aspect = this.canvas.width / this.canvas.height;
                const fov = Math.PI / 2.5; // Even wider field of view to see the large structure
                const near = 10.0;
                const far = 500.0; // Much farther to accommodate large structure and camera distance
                
                return this.perspective(fov, aspect, near, far);
            }
            
            // Matrix math utilities
            lookAt(eye, center, up) {
                const zAxis = this.normalize([eye[0] - center[0], eye[1] - center[1], eye[2] - center[2]]);
                const xAxis = this.normalize(this.cross(up, zAxis));
                const yAxis = this.cross(zAxis, xAxis);
                
                return [
                    xAxis[0], yAxis[0], zAxis[0], 0,
                    xAxis[1], yAxis[1], zAxis[1], 0,
                    xAxis[2], yAxis[2], zAxis[2], 0,
                    -this.dot(xAxis, eye), -this.dot(yAxis, eye), -this.dot(zAxis, eye), 1
                ];
            }
            
            perspective(fov, aspect, near, far) {
                const f = Math.tan(Math.PI * 0.5 - 0.5 * fov);
                const rangeInv = 1.0 / (near - far);
                
                return [
                    f / aspect, 0, 0, 0,
                    0, f, 0, 0,
                    0, 0, (near + far) * rangeInv, -1,
                    0, 0, near * far * rangeInv * 2, 0
                ];
            }
            
            normalize(v) {
                const len = Math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);
                return len > 0 ? [v[0] / len, v[1] / len, v[2] / len] : [0, 0, 0];
            }
            
            cross(a, b) {
                return [
                    a[1] * b[2] - a[2] * b[1],
                    a[2] * b[0] - a[0] * b[2],
                    a[0] * b[1] - a[1] * b[0]
                ];
            }
            
            dot(a, b) {
                return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
            }
            
            // Control methods
            async toggleAudio() {
                try {
                    if (!this.audioContext) {
                        console.error('Audio context not initialized');
                        this.updatePoetryText("Audio not initialized. Refresh page and try again.");
                        return;
                    }
                    
                    // Ensure audio context is running
                    if (this.audioContext.state === 'suspended') {
                        await this.audioContext.resume();
                        console.log('Audio context resumed');
                    }
                    
                    if (this.audioEngine) {
                        if (this.audioEngine.isPlaying) {
                            this.audioEngine.stop();
                            this.updatePoetryText("Audio stopped. Press SPACE to resume the journey...");
                        } else {
                            this.audioEngine.start();
                            this.updatePoetryText("Welcome to the hypnotic jazz poetry experience...");
                            console.log('Audio engine started');
                        }
                    } else {
                        console.error('Audio engine not initialized');
                        this.updatePoetryText("Audio engine error. Refresh page and try again.");
                    }
                } catch (error) {
                    console.error('Toggle audio error:', error);
                    this.updatePoetryText("Audio error: " + error.message);
                }
            }
            
            toggleHypnoticMode() {
                this.hypnoticMode = !this.hypnoticMode;
                const kaleidoscope = document.querySelector('.kaleidoscope');
                if (this.hypnoticMode) {
                    kaleidoscope.style.animationDuration = '5s';
                    kaleidoscope.style.opacity = '0.3';
                } else {
                    kaleidoscope.style.animationDuration = '20s';
                    kaleidoscope.style.opacity = '0.1';
                }
            }
            
            changeVisualMode(mode) {
                if (this.visualEngine) {
                    this.visualEngine.setMode(mode);
                }
                document.getElementById('mode-display').textContent = mode.replace('_', ' ');
            }
            
            changeMusicalPattern(pattern) {
                if (this.audioEngine) {
                    this.audioEngine.setPattern(pattern);
                }
                this.currentMode = pattern;
            }
            
            changePoetryStyle(style) {
                if (this.poetryEngine) {
                    this.poetryEngine.setStyle(style);
                    this.nextPoetryLine();
                }
            }
            
                         adjustParameter(paramName, minVal, maxVal, step) {
                 if (!this.params[paramName]) return;
                 
                 // Increase parameter value
                 this.params[paramName] += step;
                 
                 // Wrap around at max
                 if (this.params[paramName] > maxVal) {
                     this.params[paramName] = minVal;
                 }
                 
                 // Apply parameter changes to relevant systems
                 this.applyParameterChanges(paramName);
                 
                 // Show feedback
                 this.showParameterFeedback(paramName, this.params[paramName]);
                 
                 // Play feedback tone
                 if (this.audioEngine) {
                     const feedbackFreq = 220 + (this.params[paramName] / maxVal) * 220;
                     this.audioEngine.playNote(feedbackFreq, 0.1, 'sine', 0.05);
                 }
                 
                 console.log(`Adjusted ${paramName} to ${this.params[paramName].toFixed(3)}`);
             }
             
             applyParameterChanges(paramName) {
                 // Apply parameter changes to audio engine
                 if (this.audioEngine) {
                     switch (paramName) {
                         case 'tempo':
                             this.audioEngine.currentBPM = this.params.tempo;
                             this.audioEngine.beatInterval = 60 / this.audioEngine.currentBPM;
                             break;
                                                 case 'masterVolume':
                            if (this.audioEngine.masterGain) {
                                const safeVolume = this.audioEngine.validateAudioParam(this.params.masterVolume, 0.5, 0, 1);
                                this.audioEngine.masterGain.gain.setValueAtTime(
                                    safeVolume, 
                                    this.audioContext.currentTime
                                );
                            }
                             break;
                     }
                 }
                 
                 // Apply parameter changes to Markov chain
                 if (this.markovChain) {
                     switch (paramName) {
                         case 'learningRate':
                             this.markovChain.learningRate = this.params.learningRate;
                             break;
                         case 'explorationFactor':
                             this.markovChain.explorationFactor = this.params.explorationFactor;
                             break;
                         case 'markovMemory':
                             this.markovChain.memoryDepth = Math.floor(this.params.markovMemory * 10) + 1;
                             break;
                     }
                 }
                 
                 // Apply visual parameter changes
                 if (this.visualEngine) {
                     switch (paramName) {
                         case 'backgroundComplexity':
                             this.visualEngine.complexity = this.params.backgroundComplexity;
                             break;
                         case 'animationSpeed':
                             this.visualEngine.speed = this.params.animationSpeed;
                             break;
                         case 'colorIntensity':
                             this.visualEngine.intensity = this.params.colorIntensity;
                             break;
                     }
                 }
             }
             
             showParameterFeedback(paramName, value) {
                 // Create or update parameter feedback display
                 let feedbackDiv = document.getElementById('parameter-feedback');
                 if (!feedbackDiv) {
                     feedbackDiv = document.createElement('div');
                     feedbackDiv.id = 'parameter-feedback';
                     feedbackDiv.style.cssText = `
                         position: fixed;
                         top: 50%;
                         left: 50%;
                         transform: translate(-50%, -50%);
                         background: rgba(0, 0, 0, 0.8);
                         color: #00ff88;
                         padding: 20px;
                         border-radius: 10px;
                         border: 1px solid rgba(0, 255, 136, 0.3);
                         font-family: 'Courier New', monospace;
                         font-size: 18px;
                         z-index: 1000;
                         pointer-events: none;
                         backdrop-filter: blur(10px);
                     `;
                     document.body.appendChild(feedbackDiv);
                 }
                 
                 feedbackDiv.textContent = `${paramName}: ${value.toFixed(3)}`;
                 feedbackDiv.style.opacity = '1';
                 
                 // Fade out after 1 second
                 setTimeout(() => {
                     feedbackDiv.style.opacity = '0';
                 }, 1000);
             }
            
                         resetAll() {
                 // Reset all parameters to defaults
                 this.params = {
                     // Audio Parameters
                     masterVolume: 0.7,
                     tempo: 45.0, // Keep slow tempo for relaxing experience
                     harmonicRichness: 0.5,
                     reverbAmount: 0.3,
                     bassBoost: 0.4,
                     trebleBoost: 0.4,
                     chordSpread: 0.5,
                     melodyOctave: 1.0,
                     
                     // Visual Parameters
                     colorIntensity: 0.7,
                     animationSpeed: 0.6,
                     particleDensity: 0.5,
                     textSize: 0.5,
                     backgroundComplexity: 0.6,
                     pulseStrength: 0.8,
                     spiralTightness: 0.5,
                     waveformGain: 0.6,
                     
                     // Markov Parameters
                     markovMemory: 0.5,
                     transitionRate: 0.4,
                     explorationFactor: 0.3,
                     learningRate: 0.1,
                     stateStability: 0.6,
                     predictionWeight: 0.4,
                     adaptationSpeed: 0.2,
                     complexityBias: 0.5,
                     
                     // Advanced Algorithm Parameters
                     annealingRate: 0.5,
                     particleCount: 0.6,
                     bayesianConfidence: 0.7,
                     dendriticDepth: 0.4,
                     temperatureControl: 0.5,
                     samplingDiversity: 0.6,
                     convergenceRate: 0.3,
                     noiseFloor: 0.1,
                     
                     // Poetry Parameters
                     lineIntensity: 0.8,
                     wordSpacing: 0.5,
                     emotionalWeight: 0.7,
                     rhythmSync: 0.6,
                     semanticFlow: 0.5,
                     metaphorDensity: 0.4,
                     imageVividness: 0.8,
                     narrativeCoherence: 0.6
                 };
                 
                 // Reset animation state
                 this.smoothTime = 0;
                 this.musicEnergy = 0;
                 this.bassLevel = 0;
                 this.trebleLevel = 0;
                 this.rhythmPulse = 0;
                 
                 // Reset systems
                 if (this.audioEngine) {
                     this.audioEngine.reset();
                     this.audioEngine.currentBPM = this.params.tempo;
                     this.audioEngine.beatInterval = 60 / this.audioEngine.currentBPM;
                 }
                 if (this.visualEngine) this.visualEngine.reset();
                 if (this.poetryEngine) this.poetryEngine.reset();
                 if (this.markovChain) {
                     this.markovChain.learningRate = this.params.learningRate;
                     this.markovChain.explorationFactor = this.params.explorationFactor;
                     this.markovChain.memoryDepth = Math.floor(this.params.markovMemory * 10) + 1;
                 }
                 
                 this.updatePoetryText("All parameters reset. Ready for new hypnotic journey...");
                 this.showParameterFeedback("RESET", 1.0);
             }
            
            nextPoetryLine() {
                if (this.poetryEngine) {
                    const line = this.poetryEngine.getNextLine();
                    this.updatePoetryText(line);
                }
            }
            
            updatePoetryText(text) {
                const poetryElement = document.getElementById('poetry-text');
                
                // Clear any existing typewriter timeout
                if (this.typewriterTimeout) {
                    clearTimeout(this.typewriterTimeout);
                }
                if (this.displayTimeout) {
                    clearTimeout(this.displayTimeout);
                }
                
                // Clear current text and add typing class for cursor
                poetryElement.textContent = '';
                poetryElement.classList.add('typing');
                
                // Start typewriter effect
                this.typewriterText(poetryElement, text, 0);
            }
            
            typewriterText(element, text, index) {
                if (index < text.length) {
                    element.textContent += text.charAt(index);
                    
                    // Update colors and effects for current state
                    this.updatePoetryStyles(element);
                    
                    // Continue typewriter effect with 50ms delay per character
                    this.typewriterTimeout = setTimeout(() => {
                        this.typewriterText(element, text, index + 1);
                    }, 50);
                } else {
                    // Typewriter complete, remove typing class to hide cursor
                    element.classList.remove('typing');
                    
                    // Keep text visible for 4 seconds
                    this.displayTimeout = setTimeout(() => {
                        // Fade out effect
                        element.style.transition = 'opacity 1s ease-out';
                        element.style.opacity = '0';
                        
                        // Clear text after fade
                        setTimeout(() => {
                            element.textContent = '';
                            element.style.opacity = '1';
                            element.style.transition = 'none';
                        }, 1000);
                    }, 4000);
                }
            }
            
            updatePoetryStyles(element) {
                // Add breathing animation based on music
                const breatheSpeed = 4 - this.smoothMusicEnergy.current * 2;
                element.style.animationDuration = breatheSpeed + 's';
                
                // Color based on music
                const hue = (this.smoothTime * 20 + this.smoothMusicEnergy.current * 100) % 360;
                const saturation = 70 + this.smoothBassLevel.current * 30;
                const lightness = 60 + this.smoothRhythmPulse.current * 20;
                
                element.style.color = `hsl(${hue}, ${saturation}%, ${lightness}%)`;
                element.style.textShadow = `0 0 20px hsla(${hue}, ${saturation}%, ${lightness}%, 0.8)`;
            }
            
                                     updateStatus() {
                // Status display removed - keeping function for compatibility
                // All UI elements except volume control have been removed
            }
        }

                 // ============================================================================
         // Dendritic Markov Chain System - Ported from M5Cardputer
         // ============================================================================
         class DendriticMarkovChain {
             constructor() {
                 this.stateMatrix = {};
                 this.currentState = 'initial';
                 this.transitionHistory = [];
                 this.learningRate = 0.1;
                 this.explorationFactor = 0.3;
                 this.memoryDepth = 5;
                 this.dendriticNodes = [];
                 this.visualStates = ['spiral', 'mandala', 'waves', 'particles', 'geometry'];
                 this.audioStates = ['ambient', 'rhythmic', 'harmonic', 'melodic', 'percussive'];
                 this.poetryStates = ['contemplative', 'energetic', 'mystical', 'urban', 'cosmic'];
                 
                 // Evolution parameters
                 this.maxNodes = 80; // Maximum nodes allowed
                 this.minNodes = 30; // Minimum nodes to maintain
                 this.nextNodeId = 0;
                 this.evolutionCycle = 0;
                 this.lastEvolutionTime = 0;
                 this.evolutionInterval = 5000; // Evolve every 5 seconds for more visible changes
                 
                 this.initializeStates();
             }
             
             initializeStates() {
                 // Initialize transition probabilities
                 const allStates = [...this.visualStates, ...this.audioStates, ...this.poetryStates];
                 
                 allStates.forEach(state => {
                     this.stateMatrix[state] = {};
                     allStates.forEach(nextState => {
                         this.stateMatrix[state][nextState] = Math.random() * 0.1 + 0.05;
                     });
                 });
                 
                 // Create dendritic nodes with musical properties
                 for (let i = 0; i < 50; i++) {
                     this.dendriticNodes.push({
                         id: i,
                         connections: [],
                         activation: Math.random() * 0.3, // Start with some initial activation
                         threshold: 0.3 + Math.random() * 0.4, // More reasonable thresholds
                         decay: 0.98, // Slower decay for more sustained memory
                         state: allStates[Math.floor(Math.random() * allStates.length)],
                         // Musical properties
                         musicalNote: i % 12, // Chromatic scale mapping
                         harmonicWeight: Math.random(),
                         rhythmicPattern: Math.floor(Math.random() * 8) + 1,
                         lastActivationTime: 0,
                         // Evolution properties
                         birthTime: Date.now(),
                         fitness: 0.5,
                         usageCount: 0,
                         lastUsedTime: 0,
                         generation: 0
                     });
                 }
                 this.nextNodeId = 50; // Track next available ID
                 
                 // Connect nodes in musically meaningful patterns
                 this.dendriticNodes.forEach(node => {
                     const numConnections = Math.floor(Math.random() * 4) + 3; // 3-6 connections
                     for (let i = 0; i < numConnections; i++) {
                         let targetId;
                         
                         // Prefer harmonic connections (4ths, 5ths, octaves)
                         if (Math.random() < 0.6) {
                             const harmonicIntervals = [4, 7, 12]; // Perfect 4th, 5th, octave
                             const interval = harmonicIntervals[Math.floor(Math.random() * harmonicIntervals.length)];
                             targetId = this.findNodeByMusicalInterval(node.id, interval);
                         } else {
                             targetId = Math.floor(Math.random() * this.dendriticNodes.length);
                         }
                         
                         if (targetId !== node.id && targetId !== -1) {
                             const weight = 0.3 + Math.random() * 0.7; // Stronger connections
                             node.connections.push({
                                 target: targetId,
                                 weight: Math.random() > 0.5 ? weight : -weight,
                                 type: Math.random() > 0.3 ? 'excitatory' : 'inhibitory',
                                 musicalStrength: Math.random()
                             });
                         }
                     }
                 });
                 
                 console.log('🎵 Musical memory structure initialized with', this.dendriticNodes.length, 'nodes');
             }
             
             findNodeByMusicalInterval(sourceId, interval) {
                 const sourceNote = sourceId % 12;
                 const targetNote = (sourceNote + interval) % 12;
                 
                 // Find nodes with matching musical note
                 const candidates = this.dendriticNodes.filter(node => node.musicalNote === targetNote);
                 if (candidates.length > 0) {
                     return candidates[Math.floor(Math.random() * candidates.length)].id;
                 }
                 return -1; // No match found
             }
             
             updateMarkovState(audioData, visualParams, poetryParams) {
                 const currentTime = Date.now();
                 
                 // Run genetic evolution periodically
                 this.evolveNetwork();
                 
                 // Update dendritic node activations with musical awareness
                 this.dendriticNodes.forEach(node => {
                     node.activation *= node.decay;
                     
                     // Audio influence with harmonic resonance
                     if (this.audioStates.includes(node.state)) {
                         node.activation += audioData.energy * 0.4;
                         node.activation += audioData.rhythmPulse * 0.3;
                         
                         // Harmonic resonance - nodes with harmonic relationships activate together
                         if (audioData.energy > 0.5) {
                             node.activation += node.harmonicWeight * 0.2;
                         }
                     }
                     
                     // Visual influence
                     if (this.visualStates.includes(node.state)) {
                         node.activation += visualParams.complexity * 0.3;
                         node.activation += visualParams.intensity * 0.2;
                     }
                     
                     // Poetry influence
                     if (this.poetryStates.includes(node.state)) {
                         node.activation += poetryParams.emotionalWeight * 0.3;
                     }
                     
                     // Rhythmic pattern influence
                     const rhythmicPhase = (currentTime / 1000) % (node.rhythmicPattern / 2);
                     if (rhythmicPhase < 0.1) { // Rhythmic pulse
                         node.activation += 0.1;
                     }
                     
                     // Process connections with musical strength
                     if (node.activation > node.threshold) {
                         node.lastActivationTime = currentTime;
                         
                         node.connections.forEach(conn => {
                             const target = this.dendriticNodes.find(n => n.id === conn.target);
                             if (!target) return; // Skip if target node no longer exists
                             const musicalInfluence = conn.musicalStrength || 0.5;
                             const influence = conn.weight * node.activation * 0.15 * musicalInfluence;
                             
                             if (conn.type === 'excitatory') {
                                 target.activation += influence;
                             } else {
                                 target.activation -= Math.abs(influence) * 0.5; // Gentler inhibition
                             }
                             
                             // Clamp activation to reasonable bounds
                             target.activation = Math.max(0, Math.min(2, target.activation));
                         });
                     }
                     
                     // Clamp node activation
                     node.activation = Math.max(0, Math.min(2, node.activation));
                 });
                 
                 // Select next state based on dendritic network with musical preference
                 const activeNodes = this.dendriticNodes.filter(node => node.activation > node.threshold);
                 if (activeNodes.length > 0) {
                     // Prefer recently activated nodes for musical continuity
                     const recentlyActive = activeNodes.filter(node => 
                         currentTime - node.lastActivationTime < 5000
                     );
                     
                     const candidateNodes = recentlyActive.length > 0 ? recentlyActive : activeNodes;
                     const selectedNode = candidateNodes[Math.floor(Math.random() * candidateNodes.length)];
                     this.transitionToState(selectedNode.state);
                 }
                 
                 // Learn from transitions
                 this.updateTransitionProbabilities();
             }
             
             transitionToState(newState) {
                 if (this.currentState !== newState) {
                     this.transitionHistory.push({
                         from: this.currentState,
                         to: newState,
                         timestamp: Date.now()
                     });
                     
                     // Keep history within memory depth
                     if (this.transitionHistory.length > this.memoryDepth) {
                         this.transitionHistory.shift();
                     }
                     
                     this.currentState = newState;
                 }
             }
             
             updateTransitionProbabilities() {
                 // Reinforce successful transitions
                 this.transitionHistory.forEach((transition, index) => {
                     const weight = (index + 1) / this.transitionHistory.length; // Recent transitions have more weight
                     
                     if (this.stateMatrix[transition.from] && this.stateMatrix[transition.from][transition.to]) {
                         this.stateMatrix[transition.from][transition.to] += this.learningRate * weight;
                     }
                 });
                 
                 // Normalize probabilities
                 Object.keys(this.stateMatrix).forEach(state => {
                     const total = Object.values(this.stateMatrix[state]).reduce((sum, prob) => sum + prob, 0);
                     if (total > 0) {
                         Object.keys(this.stateMatrix[state]).forEach(nextState => {
                             this.stateMatrix[state][nextState] /= total;
                         });
                     }
                 });
             }
             
             getVisualParameters() {
                 const node = this.dendriticNodes.find(n => this.visualStates.includes(n.state) && n.activation > n.threshold);
                 if (!node) return { mode: 'spiral', intensity: 0.5, complexity: 0.5 };
                 
                 return {
                     mode: node.state,
                     intensity: Math.min(1, node.activation),
                     complexity: node.connections.length / 10,
                     dendriticInfluence: node.activation
                 };
             }
             
             getAudioParameters() {
                 const node = this.dendriticNodes.find(n => this.audioStates.includes(n.state) && n.activation > n.threshold);
                 if (!node) return { pattern: 'ambient', tempo: 45, harmony: 0.5 };
                 
                 // Keep tempo stable and within bounds
                 const clampedActivation = Math.min(1.0, Math.max(0.0, node.activation));
                 const stableTempo = 45; // Always return stable tempo
                 
                 return {
                     pattern: node.state,
                     tempo: stableTempo,
                     harmony: clampedActivation,
                     dendriticModulation: clampedActivation
                 };
             }
             
             getPoetryParameters() {
                 const node = this.dendriticNodes.find(n => this.poetryStates.includes(n.state) && n.activation > n.threshold);
                 if (!node) return { style: 'contemplative', intensity: 0.5, flow: 0.5 };
                 
                 return {
                     style: node.state,
                     intensity: Math.min(1, node.activation),
                     flow: node.connections.filter(c => c.type === 'excitatory').length / node.connections.length,
                     semanticWeight: node.activation
                 };
             }
             
             // ============================================================================
             // Genetic Evolution System
             // ============================================================================
             
             evolveNetwork() {
                 const currentTime = Date.now();
                 if (currentTime - this.lastEvolutionTime < this.evolutionInterval) return;
                 
                 this.lastEvolutionTime = currentTime;
                 this.evolutionCycle++;
                 
                 console.log(`🧬 EVOLUTION STARTING - Cycle ${this.evolutionCycle}: ${this.dendriticNodes.length} nodes`);
                 
                 // Store pre-evolution stats
                 const preEvolutionStats = {
                     totalNodes: this.dendriticNodes.length,
                     activeNodes: this.dendriticNodes.filter(n => n.activation > n.threshold).length,
                     avgGeneration: this.dendriticNodes.reduce((sum, n) => sum + (n.generation || 0), 0) / this.dendriticNodes.length
                 };
                 
                 // Update fitness scores for all nodes
                 this.updateNodeFitness();
                 
                 // Evolve connections (weights and new pathways) - make more dramatic
                 this.evolveConnections();
                 
                 // Birth new nodes if needed - make more frequent
                 this.birthNewNodes();
                 
                 // Deprecate old/unused nodes
                 this.deprecateNodes();
                 
                 // Force some dramatic changes to make evolution visible
                 this.forceEvolutionaryChanges();
                 
                 // Log post-evolution stats
                 const postEvolutionStats = {
                     totalNodes: this.dendriticNodes.length,
                     activeNodes: this.dendriticNodes.filter(n => n.activation > n.threshold).length,
                     avgGeneration: this.dendriticNodes.reduce((sum, n) => sum + (n.generation || 0), 0) / this.dendriticNodes.length
                 };
                 
                 console.log(`🧬 EVOLUTION COMPLETE - Cycle ${this.evolutionCycle}:`, {
                     before: preEvolutionStats,
                     after: postEvolutionStats,
                     changes: {
                         nodesDelta: postEvolutionStats.totalNodes - preEvolutionStats.totalNodes,
                         activeDelta: postEvolutionStats.activeNodes - preEvolutionStats.activeNodes,
                         generationDelta: postEvolutionStats.avgGeneration - preEvolutionStats.avgGeneration
                     }
                 });
             }
             
             forceEvolutionaryChanges() {
                 // Force some dramatic changes to make evolution visually obvious
                 
                 // Determine if this is desktop for enhanced effects
                 const isDesktop = !this.isMobile && window.innerWidth >= 800;
                 const enhancementMultiplier = isDesktop ? 2 : 1;
                 
                 // 1. Randomly boost some node activations to create visual "evolution bursts"
                 const burstCount = Math.floor(5 * enhancementMultiplier);
                 const randomNodes = this.dendriticNodes.sort(() => Math.random() - 0.5).slice(0, burstCount);
                 randomNodes.forEach(node => {
                     node.activation = Math.min(1, node.activation + (0.3 * enhancementMultiplier));
                     node.lastActivationTime = Date.now();
                 });
                 
                 // 2. Change musical properties of some nodes to create audible evolution
                 const musicalCount = Math.floor(3 * enhancementMultiplier);
                 const musicalNodes = this.dendriticNodes.filter(n => n.musicalNote !== undefined).slice(0, musicalCount);
                 musicalNodes.forEach(node => {
                     node.musicalNote = Math.floor(Math.random() * 12);
                     node.harmonicWeight = Math.random();
                     node.rhythmicPattern = Math.floor(Math.random() * 8) + 1;
                     // Desktop gets additional musical evolution
                     if (isDesktop) {
                         node.lastMusicGenerationTime = Date.now(); // Mark as recently musical
                     }
                 });
                 
                 // 3. Create new connections between high-fitness nodes
                 const fitNodes = this.dendriticNodes.filter(n => n.fitness > 0.6);
                 const connectionCount = Math.floor(enhancementMultiplier);
                 for (let i = 0; i < connectionCount && fitNodes.length >= 2; i++) {
                     const node1 = fitNodes[Math.floor(Math.random() * fitNodes.length)];
                     const node2 = fitNodes[Math.floor(Math.random() * fitNodes.length)];
                     
                     if (node1.id !== node2.id && !node1.connections.some(c => c.target === node2.id)) {
                         node1.connections.push({
                             target: node2.id,
                             weight: (Math.random() - 0.5) * 0.8,
                             type: Math.random() > 0.5 ? 'excitatory' : 'inhibitory',
                             musicalStrength: Math.random()
                         });
                     }
                 }
                 
                 // 4. Increase generation of some nodes to show evolution progress
                 const evolutionCount = Math.floor(2 * enhancementMultiplier);
                 const evolvingNodes = this.dendriticNodes.filter(n => n.fitness > 0.5).slice(0, evolutionCount);
                 evolvingNodes.forEach(node => {
                     node.generation = (node.generation || 0) + 1;
                 });
                 
                 // 5. Desktop-only: Create dramatic visual effects
                 if (isDesktop) {
                     // Force some nodes to become highly active for visual drama
                     const dramaticNodes = this.dendriticNodes.slice(0, 3);
                     dramaticNodes.forEach(node => {
                         node.activation = 0.9;
                         node.fitness = Math.min(1, node.fitness + 0.2);
                     });
                 }
                 
                 console.log(`🔥 ${isDesktop ? 'DESKTOP' : 'MOBILE'} evolutionary changes: ${randomNodes.length} activated, ${musicalNodes.length} musical changes, ${evolvingNodes.length} generations increased`);
                 
                 // Notify poetry engine to clear NLP cache for new evolution
                 if (this.poetryEngineRef && this.poetryEngineRef.clearEvolutionCache) {
                     this.poetryEngineRef.clearEvolutionCache();
                 }
             }
             
             updateNodeFitness() {
                 const currentTime = Date.now();
                 
                 this.dendriticNodes.forEach(node => {
                     // Base fitness starts at 0.1 to prevent complete elimination
                     let fitness = 0.1;
                     
                     // Reward recent activation
                     if (node.lastActivationTime > 0) {
                         const timeSinceActivation = currentTime - node.lastActivationTime;
                         fitness += Math.exp(-timeSinceActivation / 30000) * 0.3; // Decay over 30 seconds
                     }
                     
                     // Reward usage in music generation
                     if (node.lastMusicGenerationTime > 0) {
                         const timeSinceMusic = currentTime - node.lastMusicGenerationTime;
                         fitness += Math.exp(-timeSinceMusic / 10000) * 0.4; // Higher reward for music
                     }
                     
                     // Reward current activation level
                     fitness += node.activation * 0.2;
                     
                     // Reward connectivity (but not too much)
                     const connectionStrength = node.connections.reduce((sum, conn) => sum + Math.abs(conn.weight), 0);
                     fitness += Math.min(connectionStrength / 10, 0.2);
                     
                     // Age penalty (very gradual)
                     const age = currentTime - node.birthTime;
                     const agePenalty = Math.min(age / 300000, 0.1); // Max 0.1 penalty over 5 minutes
                     fitness -= agePenalty;
                     
                     // Update fitness with momentum (smooth changes)
                     node.fitness = node.fitness * 0.8 + fitness * 0.2;
                 });
             }
             
             evolveConnections() {
                 this.dendriticNodes.forEach(node => {
                                         // Evolve existing connection weights with enhanced musical mutations
                     node.connections.forEach(conn => {
                        // More frequent and varied mutations for musical diversity
                        if (Math.random() < 0.15) { // Increased mutation rate
                            conn.weight += (Math.random() - 0.5) * 0.15; // Larger weight changes
                             conn.weight = Math.max(-1, Math.min(1, conn.weight)); // Clamp to [-1, 1]
                         }
                        
                        // Evolve musical strength for harmonic diversity
                        if (Math.random() < 0.1) {
                            conn.musicalStrength += (Math.random() - 0.5) * 0.2;
                            conn.musicalStrength = Math.max(0, Math.min(1, conn.musicalStrength));
                         }
                         
                         // Strengthen connections between fit nodes
                         const targetNode = this.dendriticNodes.find(n => n.id === conn.target);
                         if (targetNode && node.fitness > 0.6 && targetNode.fitness > 0.6) {
                             conn.weight *= 1.02; // Slight strengthening
                         }
                     });
                     
                     // Occasionally add new connections to highly fit nodes
                     if (node.fitness > 0.7 && Math.random() < 0.05 && node.connections.length < 8) {
                         const potentialTargets = this.dendriticNodes.filter(n => 
                             n.id !== node.id && 
                             !node.connections.some(c => c.target === n.id) &&
                             n.fitness > 0.5
                         );
                         
                         if (potentialTargets.length > 0) {
                             const target = potentialTargets[Math.floor(Math.random() * potentialTargets.length)];
                             node.connections.push({
                                 target: target.id,
                                 weight: (Math.random() - 0.5) * 0.6,
                                 type: Math.random() > 0.3 ? 'excitatory' : 'inhibitory',
                                 musicalStrength: Math.random()
                             });
                         }
                     }
                 });
             }
             
             birthNewNodes() {
                 // Only birth new nodes if we're below max capacity and there's evolutionary pressure
                 if (this.dendriticNodes.length >= this.maxNodes) return;
                 
                 const avgFitness = this.dendriticNodes.reduce((sum, node) => sum + node.fitness, 0) / this.dendriticNodes.length;
                 
                 // Increased birth probability for more visible evolution
                 const birthProbability = Math.min(0.6, (this.maxNodes - this.dendriticNodes.length) / this.maxNodes * 2);
                 
                 // Lower fitness threshold and higher probability for more births
                 if (Math.random() < birthProbability && avgFitness > 0.3) {
                     // Find the most fit nodes to use as "parents"
                     const fitNodes = this.dendriticNodes.filter(n => n.fitness > avgFitness).sort((a, b) => b.fitness - a.fitness);
                     
                     if (fitNodes.length >= 2) {
                         const parent1 = fitNodes[0];
                         const parent2 = fitNodes[Math.floor(Math.random() * Math.min(5, fitNodes.length))];
                         
                         const allStates = [...this.visualStates, ...this.audioStates, ...this.poetryStates];
                         const newNode = {
                             id: this.nextNodeId++,
                             connections: [],
                             activation: (parent1.activation + parent2.activation) / 2 + (Math.random() - 0.5) * 0.1,
                             threshold: (parent1.threshold + parent2.threshold) / 2 + (Math.random() - 0.5) * 0.1,
                             decay: (parent1.decay + parent2.decay) / 2 + (Math.random() - 0.5) * 0.01,
                             state: Math.random() < 0.7 ? parent1.state : allStates[Math.floor(Math.random() * allStates.length)],
                                                         // Musical properties - inherit with enhanced mutation for diversity
                            musicalNote: Math.random() < 0.6 ? parent1.musicalNote : Math.floor(Math.random() * 12), // More mutation
                            harmonicWeight: (parent1.harmonicWeight + parent2.harmonicWeight) / 2 + (Math.random() - 0.5) * 0.4, // Larger mutations
                            rhythmicPattern: Math.random() < 0.7 ? parent1.rhythmicPattern : Math.floor(Math.random() * 8) + 1,
                             lastActivationTime: 0,
                             // Evolution properties
                             birthTime: Date.now(),
                             fitness: (parent1.fitness + parent2.fitness) / 2,
                             usageCount: 0,
                             lastUsedTime: 0,
                             generation: Math.max(parent1.generation, parent2.generation) + 1
                         };
                         
                         // Clamp values to reasonable ranges
                         newNode.activation = Math.max(0, Math.min(1, newNode.activation));
                         newNode.threshold = Math.max(0.1, Math.min(0.9, newNode.threshold));
                         newNode.decay = Math.max(0.95, Math.min(0.999, newNode.decay));
                         newNode.harmonicWeight = Math.max(0, Math.min(1, newNode.harmonicWeight));
                         
                         this.dendriticNodes.push(newNode);
                         
                         // Create initial connections for the new node
                         this.createInitialConnections(newNode, [parent1, parent2]);
                         
                         console.log(`🌱 New node born: ID ${newNode.id}, Gen ${newNode.generation}`);
                     }
                 }
             }
             
             createInitialConnections(newNode, parents) {
                 // Connect to parents
                 parents.forEach(parent => {
                     if (Math.random() < 0.8) {
                         newNode.connections.push({
                             target: parent.id,
                             weight: (Math.random() - 0.5) * 0.6,
                             type: Math.random() > 0.3 ? 'excitatory' : 'inhibitory',
                             musicalStrength: Math.random()
                         });
                     }
                 });
                 
                 // Connect to a few other fit nodes
                 const otherFitNodes = this.dendriticNodes.filter(n => 
                     n.fitness > 0.5 && 
                     !parents.includes(n) && 
                     n.id !== newNode.id
                 ).sort((a, b) => b.fitness - a.fitness).slice(0, 3);
                 
                 otherFitNodes.forEach(node => {
                     if (Math.random() < 0.4) {
                         newNode.connections.push({
                             target: node.id,
                             weight: (Math.random() - 0.5) * 0.4,
                             type: Math.random() > 0.3 ? 'excitatory' : 'inhibitory',
                             musicalStrength: Math.random()
                         });
                     }
                 });
             }
             
             deprecateNodes() {
                 // Only deprecate if we're above minimum capacity
                 if (this.dendriticNodes.length <= this.minNodes) return;
                 
                 // Find candidates for deprecation (lowest fitness, old, unused)
                 const currentTime = Date.now();
                 const candidates = this.dendriticNodes.filter(node => {
                     const age = currentTime - node.birthTime;
                     const timeSinceUse = node.lastUsedTime > 0 ? currentTime - node.lastUsedTime : age;
                     
                     return (
                         node.fitness < 0.2 && // Very low fitness
                         age > 60000 && // At least 1 minute old
                         timeSinceUse > 30000 // Unused for 30 seconds
                     );
                 }).sort((a, b) => a.fitness - b.fitness);
                 
                 // Deprecate up to 10% of nodes per cycle, but not too many at once
                 const maxToDeprecate = Math.min(
                     Math.floor(this.dendriticNodes.length * 0.1),
                     this.dendriticNodes.length - this.minNodes,
                     3 // Max 3 per cycle for stability
                 );
                 
                 const toDeprecate = candidates.slice(0, maxToDeprecate);
                 
                 toDeprecate.forEach(node => {
                     // Remove connections to this node from other nodes
                     this.dendriticNodes.forEach(otherNode => {
                         otherNode.connections = otherNode.connections.filter(conn => conn.target !== node.id);
                     });
                     
                     console.log(`💀 Node deprecated: ID ${node.id}, Fitness ${node.fitness.toFixed(3)}`);
                 });
                 
                 // Remove the deprecated nodes
                 this.dendriticNodes = this.dendriticNodes.filter(node => !toDeprecate.includes(node));
                 
                 // Clean up any remaining invalid connections (safety check)
                 this.dendriticNodes.forEach(node => {
                     node.connections = node.connections.filter(conn => 
                         this.dendriticNodes.some(n => n.id === conn.target)
                     );
                 });
             }
         }

         // ============================================================================
         // Jazz Audio Engine - Web Audio API Implementation
         // ============================================================================
         class JazzAudioEngine {
                         constructor(audioContext, params) {
                 this.audioContext = audioContext;
                 this.isPlaying = false;
                 this.params = params;
                 this.currentBPM = params ? params.tempo : 45; // Use parameter tempo
                 this.currentPattern = 'ambient_meditation';
                
                try {
                    this.setupAudioNodes();
                    this.setupAnalyser();
                    this.setupOscillators();
                    console.log('JazzAudioEngine initialized successfully');
                } catch (error) {
                    console.error('JazzAudioEngine initialization failed:', error);
                    throw error;
                }
            }
            
            setupAudioNodes() {
                this.masterGain = this.audioContext.createGain();
                this.masterGain.connect(this.audioContext.destination);
                this.masterGain.gain.value = 0.15; // Much quieter overall
            }
            
            setupAnalyser() {
                this.analyser = this.audioContext.createAnalyser();
                this.analyser.fftSize = 256;
                this.analyser.connect(this.masterGain);
                
                this.bufferLength = this.analyser.frequencyBinCount;
                this.dataArray = new Uint8Array(this.bufferLength);
            }
            
            setupOscillators() {
                this.oscillators = [];
                this.currentChord = [];
                this.nextBeatTime = 0;
                this.beatInterval = 60 / this.currentBPM;
            }
            
            start() {
                this.isPlaying = true;
                this.nextBeatTime = this.audioContext.currentTime;
                this.scheduleNextBeat();
            }
            
            stop() {
                this.isPlaying = false;
                this.stopAllOscillators();
            }
            
            scheduleNextBeat() {
                if (!this.isPlaying) return;
                
                const currentTime = this.audioContext.currentTime;
                
                if (currentTime >= this.nextBeatTime) {
                    this.playBeat();
                    this.nextBeatTime += this.beatInterval;
                }
                
                setTimeout(() => this.scheduleNextBeat(), 10);
            }
            
            playBeat() {
                // Generate memory-driven musical composition with proper timing
                if (this.memoryStructure) {
                    const chord = this.generateMemoryChord();
                    const duration = this.calculateMemoryDuration();
                    this.playChord(chord, duration);
                    
                    // Much less frequent melody - only occasionally
                    if (this.shouldPlayMemoryMelody()) {
                        setTimeout(() => {
                            const melody = this.generateMemoryMelody();
                            this.playMelody(melody);
                        }, this.beatInterval * 1000 * 2.0); // Wait 2 beats before melody
                    }
                } else {
                    // Fallback to simple ambient
                    const chord = this.generateAmbientChord();
                    this.playChord(chord, 4.0);
                }
            }
            
            setMemoryStructure(markovChain) {
                this.memoryStructure = markovChain;
                
                // Jazz conversation state driven by dendritic memory evolution
                this.jazzConversation = {
                    lastChordRoot: 60, // C4
                    lastChordType: 'triad',
                    conversationPhase: 'statement', // statement, response, development, resolution
                    phaseStartTime: Date.now(),
                    phaseDuration: 6000, // 6 seconds per phase for dynamic conversation
                    callResponseHistory: [],
                    improvisationLevel: 0.3,
                    memoryInfluence: 0.5, // How much the dendritic network influences the conversation
                    evolutionSync: true // Sync conversation phases with network evolution
                };
            }
            
            generateMemoryChord() {
                if (!this.memoryStructure || !this.memoryStructure.dendriticNodes) {
                    return this.generateAmbientChord();
                }
                
                                // Update jazz conversation phase based on dendritic memory evolution
                this.updateJazzConversationPhase();
                
                // Use memory complexity to determine harmonic sophistication
                const activeNodes = this.memoryStructure.dendriticNodes.filter(node => node.activation > node.threshold);
                const complexity = Math.min(1, activeNodes.length / 20); // 0-1 complexity based on active nodes
                
                // Mark only a subset of nodes as currently being used for music generation
                const currentTime = Date.now();
                const selectedNodes = activeNodes.slice(0, Math.min(5, Math.ceil(activeNodes.length * 0.3))); // Only use 30% of active nodes, max 5
                
                                 selectedNodes.forEach(node => {
                     node.lastMusicGenerationTime = currentTime;
                     node.isCurrentlyGeneratingMusic = true;
                     node.lastUsedTime = currentTime;
                     node.usageCount++;
                 });
                
                // Clear the music generation flag after a short delay
                setTimeout(() => {
                    selectedNodes.forEach(node => {
                        node.isCurrentlyGeneratingMusic = false;
                    });
                }, 1000); // Longer duration for chord
                
               // Generate jazz conversation chord driven by dendritic memory
               const rootNote = this.getJazzConversationRoot(complexity, activeNodes);
                const scale = this.getScaleFromComplexity(complexity);
               const chordType = this.getJazzConversationChordType(activeNodes, complexity);
               
               const chord = this.buildChordFromTheory(rootNote, scale, chordType, complexity);
               
               // Update conversation history with memory influence
               this.updateJazzConversationHistory(rootNote, chordType, activeNodes, currentTime);
               
               return chord;
            }
            
            updateJazzConversationPhase() {
                const currentTime = Date.now();
                const phaseElapsed = currentTime - this.jazzConversation.phaseStartTime;
                
                // Sync with network evolution if enabled
                if (this.jazzConversation.evolutionSync && this.memoryStructure) {
                    const evolutionProgress = (currentTime - this.memoryStructure.lastEvolutionTime) / this.memoryStructure.evolutionInterval;
                    
                    // Phase changes align with evolution cycles
                    if (evolutionProgress > 0.25 && phaseElapsed > this.jazzConversation.phaseDuration * 0.5) {
                        this.advanceJazzPhase(currentTime);
                    }
                } else if (phaseElapsed > this.jazzConversation.phaseDuration) {
                    this.advanceJazzPhase(currentTime);
                }
            }
            
            advanceJazzPhase(currentTime) {
                // Cycle through conversation phases with memory influence
                const phases = ['statement', 'response', 'development', 'resolution'];
                const currentIndex = phases.indexOf(this.jazzConversation.conversationPhase);
                const nextIndex = (currentIndex + 1) % phases.length;
                
                this.jazzConversation.conversationPhase = phases[nextIndex];
                this.jazzConversation.phaseStartTime = currentTime;
                
                // Adjust improvisation level based on phase and memory activity
                const activeNodes = this.memoryStructure.dendriticNodes.filter(node => node.activation > node.threshold);
                const memoryActivity = activeNodes.length / this.memoryStructure.dendriticNodes.length;
                
                switch (this.jazzConversation.conversationPhase) {
                    case 'statement':
                        this.jazzConversation.improvisationLevel = 0.2 + memoryActivity * 0.2; // Conservative start, memory influenced
                        break;
                    case 'response':
                        this.jazzConversation.improvisationLevel = 0.4 + memoryActivity * 0.3; // Answer the call
                        break;
                    case 'development':
                        this.jazzConversation.improvisationLevel = 0.6 + memoryActivity * 0.4; // Get adventurous with memory
                        break;
                    case 'resolution':
                        this.jazzConversation.improvisationLevel = 0.3 + memoryActivity * 0.1; // Return home gently
                        break;
                }
                
                // Update memory influence based on evolution cycle
                if (this.memoryStructure) {
                    this.jazzConversation.memoryInfluence = 0.3 + (this.memoryStructure.evolutionCycle % 5) * 0.15;
                }
            }
            
            getJazzConversationRoot(complexity, activeNodes) {
                const phase = this.jazzConversation.conversationPhase;
                const lastRoot = this.jazzConversation.lastChordRoot;
                const improvisationLevel = this.jazzConversation.improvisationLevel;
                const memoryInfluence = this.jazzConversation.memoryInfluence;
                
                // Use dendritic memory to influence root selection
                const avgMusicalNote = activeNodes.length > 0 ? 
                    activeNodes.reduce((sum, node) => sum + node.musicalNote, 0) / activeNodes.length : 6;
                const memoryRootSuggestion = 60 + (avgMusicalNote % 12); // Convert to actual note
                
                // Jazz conversation root movement based on phase and memory
                switch (phase) {
                    case 'statement':
                        // Establish tonal center influenced by memory
                        if (Math.random() < memoryInfluence) {
                            return memoryRootSuggestion;
                        }
                        const stableRoots = [60, 65, 67]; // I, IV, V
                        return stableRoots[Math.floor(Math.random() * stableRoots.length)];
                        
                    case 'response':
                        // Respond to statement - memory creates harmonic relationships
                        const memoryInterval = Math.floor(avgMusicalNote) % 7; // Use memory for interval
                        const responseInterval = [0, 2, 4, 5, 7, 9, 11][memoryInterval]; // Scale degrees
                        
                        if (Math.random() < memoryInfluence) {
                            return lastRoot + responseInterval;
                        } else {
                            // Traditional jazz response - 4ths/5ths
                            const jazzInterval = Math.random() < 0.7 ? 7 : 5;
                            return lastRoot + (Math.random() < 0.5 ? jazzInterval : -jazzInterval);
                        }
                        
                    case 'development':
                        // Explore with memory-driven harmonic adventure
                        if (Math.random() < memoryInfluence * improvisationLevel) {
                            // Memory-driven chromatic exploration
                            const memoryShift = (avgMusicalNote * complexity) % 6 - 3; // -3 to +3 semitones
                            return lastRoot + Math.round(memoryShift);
                        } else if (Math.random() < improvisationLevel) {
                            // Tritone substitution (very jazzy)
                            return lastRoot + 6;
                        } else {
                            // Chromatic approach
                            return lastRoot + (Math.random() < 0.5 ? 1 : -1);
                        }
                        
                    case 'resolution':
                        // Return to tonal center with memory-influenced resolution
                        if (Math.random() < memoryInfluence) {
                            // Memory suggests the resolution
                            return Math.round(memoryRootSuggestion / 12) * 12 + 60; // Octave-adjusted memory root
                        } else {
                            // Traditional resolution
                            const resolutionRoots = [60, 67]; // I or V
                            return resolutionRoots[Math.floor(Math.random() * resolutionRoots.length)];
                        }
                        
                    default:
                        return this.getCurrentRootNote();
                }
            }
            
            getJazzConversationChordType(activeNodes, complexity) {
                const phase = this.jazzConversation.conversationPhase;
                const improvisationLevel = this.jazzConversation.improvisationLevel;
                const memoryInfluence = this.jazzConversation.memoryInfluence;
                
                const avgActivation = activeNodes.length > 0 ? 
                    activeNodes.reduce((sum, node) => sum + node.activation, 0) / activeNodes.length : 0.5;
                const avgHarmonicWeight = activeNodes.length > 0 ?
                    activeNodes.reduce((sum, node) => sum + node.harmonicWeight, 0) / activeNodes.length : 0.5;
                
                // Jazz conversation chord complexity influenced by memory evolution
                const memoryComplexity = avgHarmonicWeight * memoryInfluence;
                const jazzComplexity = (complexity + improvisationLevel + avgActivation + memoryComplexity) / 4;
                
                switch (phase) {
                    case 'statement':
                        // Clear, strong chords influenced by memory sophistication
                        return jazzComplexity < 0.3 ? 'triad' : 
                               jazzComplexity < 0.6 ? 'seventh' : 'extended';
                        
                    case 'response':
                        // Answer with memory-influenced harmonic sophistication
                        const lastType = this.jazzConversation.lastChordType;
                        if (Math.random() < memoryInfluence) {
                            // Memory drives the response complexity
                            return jazzComplexity < 0.4 ? 'seventh' : 
                                   jazzComplexity < 0.7 ? 'extended' : 'altered';
                        } else if (lastType === 'triad') {
                            return Math.random() < 0.7 ? 'seventh' : 'extended';
                        } else {
                            return lastType; // Mirror the complexity
                        }
                        
                    case 'development':
                        // Memory-driven harmonic adventure
                        return jazzComplexity < 0.2 ? 'seventh' : 
                               jazzComplexity < 0.5 ? 'extended' : 'altered';
                        
                    case 'resolution':
                        // Memory-influenced resolution - can be simple or sophisticated
                        return jazzComplexity < 0.4 ? 'triad' : 
                               jazzComplexity < 0.7 ? 'seventh' : 'extended';
                        
                    default:
                        return this.getChordTypeFromMemory(activeNodes, complexity);
                }
            }
            
            updateJazzConversationHistory(rootNote, chordType, activeNodes, currentTime) {
                // Update conversation history with memory context
                this.jazzConversation.lastChordRoot = rootNote;
                this.jazzConversation.lastChordType = chordType;
                
                const memoryContext = {
                    activeNodeCount: activeNodes.length,
                    avgActivation: activeNodes.length > 0 ? 
                        activeNodes.reduce((sum, node) => sum + node.activation, 0) / activeNodes.length : 0,
                    avgGeneration: activeNodes.length > 0 ?
                        activeNodes.reduce((sum, node) => sum + (node.generation || 0), 0) / activeNodes.length : 0,
                    evolutionCycle: this.memoryStructure.evolutionCycle
                };
                
                this.jazzConversation.callResponseHistory.push({
                    root: rootNote,
                    type: chordType,
                    phase: this.jazzConversation.conversationPhase,
                    time: currentTime,
                    memoryContext: memoryContext
                });
                
                // Keep only recent history (last 8 chords for conversation memory)
                if (this.jazzConversation.callResponseHistory.length > 8) {
                    this.jazzConversation.callResponseHistory.shift();
                }
            }
            
            getCurrentRootNote() {
                // Use memory transitions and network evolution to determine root note
                if (!this.memoryStructure.transitionHistory.length) return 60; // C4
                
                // More dynamic root note selection based on network evolution
                const recentTransitions = this.memoryStructure.transitionHistory.slice(-15);
                const activeNodes = this.memoryStructure.dendriticNodes.filter(node => node.activation > node.threshold);
                
                let rootIndex = 0;
                
                // Factor in network evolution cycle for more variation
                const evolutionInfluence = this.memoryStructure.evolutionCycle % 7; // 7 possible roots
                rootIndex += evolutionInfluence;
                
                // Use node musical properties for harmonic evolution
                if (activeNodes.length > 0) {
                    const avgMusicalNote = activeNodes.reduce((sum, node) => sum + node.musicalNote, 0) / activeNodes.length;
                    rootIndex += Math.floor(avgMusicalNote) % 5; // Add musical note influence
                }
                
                // Count significant transitions for additional variation
                recentTransitions.forEach(transition => {
                    if (transition.from !== transition.to) {
                        rootIndex += this.hashString(transition.to) % 4;
                    }
                });
                
                // Expanded chord roots for more harmonic variety: C, D, E, F, G, A, B
                const expandedRoots = [60, 62, 64, 65, 67, 69, 71]; // Full chromatic options
                return expandedRoots[rootIndex % expandedRoots.length];
            }
            
            getScaleFromComplexity(complexity) {
                // Expanded scale selection based on network evolution and complexity
                const activeNodes = this.memoryStructure.dendriticNodes.filter(node => node.activation > node.threshold);
                
                // Use evolution cycle and node properties for scale variation
                const evolutionMod = this.memoryStructure.evolutionCycle % 8;
                const avgHarmonicWeight = activeNodes.length > 0 ? 
                    activeNodes.reduce((sum, node) => sum + node.harmonicWeight, 0) / activeNodes.length : 0.5;
                
                const scales = [
                    [0, 2, 4, 5, 7, 9, 11],     // Major (bright, happy)
                    [0, 2, 3, 5, 7, 9, 10],     // Natural minor (melancholic)
                    [0, 2, 3, 5, 7, 8, 11],     // Harmonic minor (exotic)
                    [0, 2, 4, 6, 7, 9, 11],     // Lydian (dreamy, floating)
                    [0, 2, 3, 5, 7, 9, 11],     // Dorian (jazzy, sophisticated)
                    [0, 1, 3, 4, 6, 8, 10],     // Diminished (tense, complex)
                    [0, 2, 4, 7, 9],            // Pentatonic (simple, universal)
                    [0, 1, 4, 5, 7, 8, 11],     // Hungarian minor (dramatic)
                    [0, 3, 5, 6, 7, 10],        // Blues scale (soulful)
                    [0, 1, 3, 5, 6, 8, 10]      // Whole-half diminished (jazz)
                ];
                
                // Select scale based on complexity, evolution, and harmonic weight
                let scaleIndex = Math.floor(complexity * 4); // Base on complexity
                scaleIndex += evolutionMod % 3; // Add evolution variation
                scaleIndex += Math.floor(avgHarmonicWeight * 3); // Add harmonic influence
                
                return scales[scaleIndex % scales.length];
            }
            
            getChordTypeFromMemory(activeNodes, complexity) {
                if (activeNodes.length === 0) return 'triad';
                
                // Enhanced chord selection using evolved network properties
                const avgActivation = activeNodes.reduce((sum, node) => sum + node.activation, 0) / activeNodes.length;
                const avgRhythmicPattern = activeNodes.reduce((sum, node) => sum + node.rhythmicPattern, 0) / activeNodes.length;
                const avgGeneration = activeNodes.reduce((sum, node) => sum + (node.generation || 0), 0) / activeNodes.length;
                
                // Evolution influences chord sophistication
                const evolutionInfluence = (this.memoryStructure.evolutionCycle % 10) / 10;
                const generationInfluence = Math.min(avgGeneration / 10, 0.5); // Newer generations = more complex
                
                const totalComplexity = (complexity + evolutionInfluence + generationInfluence) / 3;
                
                if (totalComplexity < 0.2 && avgActivation < 0.5) {
                    return 'triad'; // Simple major/minor triads
                } else if (totalComplexity < 0.4 && avgRhythmicPattern < 4) {
                    return 'seventh'; // Add 7th for richness
                } else if (totalComplexity < 0.6) {
                    return 'extended'; // 9th, 11th chords
                } else if (totalComplexity < 0.8) {
                    return 'altered'; // Altered dominants, complex jazz chords
                } else {
                    return 'altered'; // Complex jazz harmonies
                }
            }
            
            buildChordFromTheory(rootMidi, scale, chordType, complexity) {
                const rootFreq = this.midiToFreq(rootMidi);
                const chord = [rootFreq]; // Always include root
                
                // Build chord based on music theory
                switch (chordType) {
                    case 'triad':
                        // Root, 3rd, 5th
                        chord.push(this.midiToFreq(rootMidi + scale[2])); // 3rd
                        chord.push(this.midiToFreq(rootMidi + scale[4])); // 5th
                        break;
                        
                    case 'seventh':
                        // Root, 3rd, 5th, 7th
                        chord.push(this.midiToFreq(rootMidi + scale[2])); // 3rd
                        chord.push(this.midiToFreq(rootMidi + scale[4])); // 5th
                        chord.push(this.midiToFreq(rootMidi + scale[6])); // 7th
                        break;
                        
                    case 'extended':
                        // Root, 3rd, 5th, 7th, 9th
                        chord.push(this.midiToFreq(rootMidi + scale[2])); // 3rd
                        chord.push(this.midiToFreq(rootMidi + scale[4])); // 5th
                        chord.push(this.midiToFreq(rootMidi + scale[6])); // 7th
                        chord.push(this.midiToFreq(rootMidi + 12 + scale[1])); // 9th (octave up)
                        break;
                        
                    case 'altered':
                        // Complex jazz harmony with alterations
                        chord.push(this.midiToFreq(rootMidi + scale[2])); // 3rd
                        chord.push(this.midiToFreq(rootMidi + scale[4])); // 5th
                        chord.push(this.midiToFreq(rootMidi + scale[6])); // 7th
                        chord.push(this.midiToFreq(rootMidi + 12 + scale[1])); // 9th
                        if (complexity > 0.9) {
                            chord.push(this.midiToFreq(rootMidi + 12 + scale[3])); // 11th
                        }
                        break;
                }
                
                return chord;
            }
            
            midiToFreq(midiNote) {
                return 440 * Math.pow(2, (midiNote - 69) / 12);
            }
            
            generateMemoryMelody() {
                if (!this.memoryStructure || !this.memoryStructure.dendriticNodes) {
                    return this.generateGentleMelody();
                }
                
                // Use memory transitions to create melodic movement
                const recentTransitions = this.memoryStructure.transitionHistory.slice(-4);
                if (recentTransitions.length === 0) {
                    return this.generateGentleMelody();
                }
                
                // Get current harmonic context
                const activeNodes = this.memoryStructure.dendriticNodes.filter(node => node.activation > node.threshold);
                const complexity = Math.min(1, activeNodes.length / 20);
                const scale = this.getScaleFromComplexity(complexity);
                const rootNote = this.getCurrentRootNote();
                
                // Mark only a few nodes as currently being used for melody generation
                const currentTime = Date.now();
                const melodyNodes = activeNodes.slice(0, Math.min(3, Math.ceil(activeNodes.length * 0.2))); // Only use 20% of active nodes, max 3
                
                                 melodyNodes.forEach(node => {
                     node.lastMusicGenerationTime = currentTime;
                     node.isCurrentlyGeneratingMusic = true;
                     node.lastUsedTime = currentTime;
                     node.usageCount++;
                 });
                
                // Clear the music generation flag after a short delay
                setTimeout(() => {
                    melodyNodes.forEach(node => {
                        node.isCurrentlyGeneratingMusic = false;
                    });
                }, 1200); // Longer duration for melody
                
                const melody = [];
                let currentNote = rootNote + 12; // Start an octave up
                
                recentTransitions.forEach((transition, index) => {
                    // Create melodic motion based on memory transitions
                    const stateHash = this.hashString(transition.to);
                    const direction = (stateHash % 3) - 1; // -1, 0, or 1 (down, stay, up)
                    const stepSize = (stateHash % 4) + 1; // 1-4 scale steps
                    
                    // Move melodically within the scale
                    const currentScaleIndex = this.findNearestScaleIndex(currentNote - rootNote, scale);
                    let newScaleIndex = currentScaleIndex + (direction * stepSize);
                    
                    // Keep melody in reasonable range (2 octaves)
                    newScaleIndex = Math.max(0, Math.min(13, newScaleIndex));
                    
                    // Convert back to MIDI note
                    const octave = Math.floor(newScaleIndex / 7);
                    const scaleStep = newScaleIndex % 7;
                    currentNote = rootNote + 12 + (octave * 12) + scale[scaleStep];
                    
                    // Add some musical phrasing - occasional rests and longer notes
                    if (index > 0 && stateHash % 5 === 0) {
                        // Rest (silence)
                        melody.push(0);
                    } else {
                        melody.push(this.midiToFreq(currentNote));
                    }
                });
                
                return melody;
            }
            
            findNearestScaleIndex(interval, scale) {
                // Find the closest scale degree to the given interval
                let closestIndex = 0;
                let closestDistance = Math.abs(scale[0] - interval);
                
                for (let i = 1; i < scale.length; i++) {
                    const distance = Math.abs(scale[i] - interval);
                    if (distance < closestDistance) {
                        closestDistance = distance;
                        closestIndex = i;
                    }
                }
                
                return closestIndex;
            }
            
            shouldPlayMemoryMelody() {
                if (!this.memoryStructure || !this.jazzConversation) return Math.random() < 0.02;
                
                // Jazz conversation melody - more dynamic and responsive
                const phase = this.jazzConversation.conversationPhase;
                const improvisationLevel = this.jazzConversation.improvisationLevel;
                const memoryInfluence = this.jazzConversation.memoryInfluence;
                
                const activeNodes = this.memoryStructure.dendriticNodes.filter(node => node.activation > node.threshold);
                const activityLevel = activeNodes.length / this.memoryStructure.dendriticNodes.length;
                
                // Jazz conversation timing - syncopated and phase-aware
                const currentBeat = Math.floor((Date.now() / 1000) / this.beatInterval) % 8;
                
                // Phase-based melody probability for jazz conversation
                let melodyProbability = 0.02; // Base probability
                
                switch (phase) {
                    case 'statement':
                        melodyProbability = 0.06 * (1 + memoryInfluence); // Melodic statements influenced by memory
                        break;
                    case 'response':
                        melodyProbability = 0.15 * (1 + improvisationLevel); // Answer the harmonic call with melody
                        break;
                    case 'development':
                        melodyProbability = 0.22 * (1 + memoryInfluence * improvisationLevel); // Most melodic activity during development
                        break;
                    case 'resolution':
                        melodyProbability = 0.10 * (1 + memoryInfluence * 0.5); // Gentle melodic resolution
                        break;
                }
                
                // Increase probability with activity and memory evolution
                melodyProbability *= (1 + activityLevel + memoryInfluence);
                
                // Jazz syncopation - play on various beats for conversation feel
                const isJazzBeat = (currentBeat === 0 || currentBeat === 3 || currentBeat === 6); // 1, 4, 7 (syncopated)
                const isMemoryBeat = (currentBeat % 2 === Math.floor(memoryInfluence * 2)); // Memory-influenced timing
                
                return (isJazzBeat || isMemoryBeat) && activityLevel > 0.25 && Math.random() < melodyProbability;
            }
            
            calculateMemoryDuration() {
                if (!this.memoryStructure) return 8.0; // Much longer default
                
                // Much longer, more stable chord durations
                const activeNodes = this.memoryStructure.dendriticNodes.filter(node => node.activation > node.threshold);
                const avgActivation = activeNodes.reduce((sum, node) => sum + node.activation, 0) / activeNodes.length || 0.5;
                
                // Much longer musical durations for ambient feel
                const musicalDurations = [12.0, 8.0, 6.0, 4.0]; // Much longer durations
                const durationIndex = Math.floor(avgActivation * musicalDurations.length);
                const baseDuration = musicalDurations[Math.min(durationIndex, musicalDurations.length - 1)];
                
                // Less tempo sensitivity for more stable timing
                return baseDuration * Math.max(0.5, (60 / this.currentBPM));
            }
            
            hashString(str) {
                let hash = 0;
                for (let i = 0; i < str.length; i++) {
                    const char = str.charCodeAt(i);
                    hash = ((hash << 5) - hash) + char;
                    hash = hash & hash; // Convert to 32-bit integer
                }
                return Math.abs(hash);
            }
            
            generateAmbientChord() {
                // Peaceful, consonant major chords in lower register
                const peacefulChords = [
                    [130.81, 164.81, 196.00], // C Major (lower)
                    [146.83, 184.99, 220.00], // D Major
                    [164.81, 207.65, 246.94], // E Major
                    [174.61, 220.00, 261.63], // F Major
                    [196.00, 246.94, 293.66], // G Major
                    [220.00, 277.18, 329.63]  // A Major
                ];
                
                // Slow progression through peaceful chords
                const index = Math.floor(Date.now() / 12000) % peacefulChords.length;
                return peacefulChords[index];
            }
            
            generateGentleMelody() {
                // Simple, peaceful pentatonic scale
                const pentatonic = [0, 2, 4, 7, 9]; // C, D, E, G, A
                const baseFreq = 523.25; // C5
                
                const melody = [];
                // Shorter, gentler melodies
                for (let i = 0; i < 2; i++) {
                    const scaleIndex = Math.floor(Math.random() * pentatonic.length);
                    const semitones = pentatonic[scaleIndex];
                    const freq = baseFreq * Math.pow(2, semitones / 12);
                    melody.push(freq);
                }
                
                return melody;
            }
            
            generateMelody() {
                const scales = {
                    ambient_meditation: [1, 1.125, 1.25, 1.5, 1.625, 2],
                    bebop: [1, 1.125, 1.25, 1.375, 1.5, 1.625, 1.75, 1.875, 2],
                    modal: [1, 1.125, 1.25, 1.5, 1.625, 1.75, 2],
                    free_jazz: [1, 1.1, 1.3, 1.4, 1.6, 1.8, 1.9, 2.1]
                };
                
                const scale = scales[this.currentPattern] || scales.jazz_fusion;
                const baseFreq = 440; // A4
                
                const melody = [];
                for (let i = 0; i < 4; i++) {
                    const scaleIndex = Math.floor(Math.random() * scale.length);
                    melody.push(baseFreq * scale[scaleIndex]);
                }
                
                return melody;
            }
            
            playChord(frequencies, duration) {
                frequencies.forEach((freq, index) => {
                    setTimeout(() => {
                        this.playNote(freq, duration * 0.9, 'sine', 0.06); // Much quieter, sine wave
                    }, index * 200); // Slower arpeggio effect
                });
            }
            
            playMelody(frequencies) {
                frequencies.forEach((freq, index) => {
                    const noteDelay = index * this.beatInterval * 1000 * 2.0; // Half note timing - much slower
                    
                    setTimeout(() => {
                        if (freq > 0) { // Only play if not a rest (0 = silence)
                            const noteDuration = this.beatInterval * 1.5; // Longer, more sustained notes
                            this.playNote(freq, noteDuration, 'sine', 0.08); // Quieter volume
                        }
                        // If freq is 0, it's a rest - do nothing (silence)
                    }, noteDelay);
                });
            }
            
            playNote(frequency, duration, waveType = 'sine', volume = 0.1) {
                // Validate and sanitize audio parameters
                const safeFrequency = this.validateAudioParam(frequency, 440, 20, 20000); // Default 440Hz, range 20Hz-20kHz
                const safeDuration = this.validateAudioParam(duration, 0.5, 0.01, 10); // Default 0.5s, range 0.01s-10s
                const safeVolume = this.validateAudioParam(volume, 0.1, 0, 1); // Default 0.1, range 0-1
                
                if (safeFrequency !== frequency) {
                    console.warn(`🔧 Audio: Fixed invalid frequency ${frequency} → ${safeFrequency}`);
                }
                if (safeDuration !== duration) {
                    console.warn(`🔧 Audio: Fixed invalid duration ${duration} → ${safeDuration}`);
                }
                if (safeVolume !== volume) {
                    console.warn(`🔧 Audio: Fixed invalid volume ${volume} → ${safeVolume}`);
                }
                
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.type = waveType;
                oscillator.frequency.setValueAtTime(safeFrequency, this.audioContext.currentTime);
                
                gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
                gainNode.gain.linearRampToValueAtTime(safeVolume, this.audioContext.currentTime + 0.01);
                gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + safeDuration);
                
                oscillator.connect(gainNode);
                gainNode.connect(this.analyser);
                
                oscillator.start(this.audioContext.currentTime);
                oscillator.stop(this.audioContext.currentTime + safeDuration);
                
                this.oscillators.push(oscillator);
                
                // Clean up
                oscillator.onended = () => {
                    const index = this.oscillators.indexOf(oscillator);
                    if (index > -1) {
                        this.oscillators.splice(index, 1);
                    }
                };
            }
            
            // Validate and sanitize audio parameters to prevent Web Audio API errors
            validateAudioParam(value, defaultValue, minValue, maxValue) {
                // Check if value is finite and not NaN
                if (!isFinite(value) || isNaN(value) || value === null || value === undefined) {
                    return defaultValue;
                }
                
                // Clamp value to valid range
                return Math.max(minValue, Math.min(maxValue, value));
            }
            
            stopAllOscillators() {
                this.oscillators.forEach(osc => {
                    try {
                        osc.stop();
                    } catch (e) {
                        // Oscillator might already be stopped
                    }
                });
                this.oscillators = [];
            }
            
            getAudioData() {
                this.analyser.getByteFrequencyData(this.dataArray);
                
                // Calculate energy levels
                let totalEnergy = 0;
                let bassEnergy = 0;
                let trebleEnergy = 0;
                
                const bassEnd = Math.floor(this.bufferLength * 0.1);
                const trebleStart = Math.floor(this.bufferLength * 0.7);
                
                for (let i = 0; i < this.bufferLength; i++) {
                    const value = this.dataArray[i] / 255;
                    totalEnergy += value;
                    
                    if (i < bassEnd) {
                        bassEnergy += value;
                    } else if (i > trebleStart) {
                        trebleEnergy += value;
                    }
                }
                
                const energy = totalEnergy / this.bufferLength;
                const bass = bassEnergy / bassEnd;
                const treble = trebleEnergy / (this.bufferLength - trebleStart);
                
                // Calculate rhythm pulse (simplified beat detection)
                const rhythmPulse = Math.max(0, (energy - 0.1) * 2);
                
                return {
                    energy: Math.min(1, energy),
                    bass: Math.min(1, bass),
                    treble: Math.min(1, treble),
                    rhythmPulse: Math.min(1, rhythmPulse)
                };
            }
            
            setPattern(pattern) {
                this.currentPattern = pattern;
                
                // Adjust BPM based on pattern
                const bpmMap = {
                    jazz_fusion: 120,
                    bebop: 140,
                    modal: 100,
                    free_jazz: 160
                };
                
                this.currentBPM = bpmMap[pattern] || 120;
                this.beatInterval = 60 / this.currentBPM;
            }
            
            adjustTempo(delta) {
                this.currentBPM = Math.max(60, Math.min(200, this.currentBPM + delta * 20));
                this.beatInterval = 60 / this.currentBPM;
            }
            
            adjustVolume(delta) {
                const currentVolume = this.masterGain.gain.value;
                const newVolume = this.validateAudioParam(currentVolume + delta, 0.5, 0, 1);
                this.masterGain.gain.setValueAtTime(newVolume, this.audioContext.currentTime);
            }
            
            reset() {
                this.stop();
                this.currentBPM = 120;
                this.currentPattern = 'jazz_fusion';
                this.beatInterval = 60 / this.currentBPM;
            }
        }

        // ============================================================================
        // Hypnotic Visual Engine
        // ============================================================================
        class HypnoticVisualEngine {
            constructor(canvas, gl) {
                this.canvas = canvas;
                this.gl = gl;
                this.mode = 'sacred_geometry';
                this.complexity = 0.5;
                this.speed = 0.5;
                this.intensity = 0.5;
            }
            
            update(audioData) {
                this.audioData = audioData;
                
                // Update kaleidoscope based on music
                const kaleidoscope = document.querySelector('.kaleidoscope');
                if (kaleidoscope) {
                    const rotationSpeed = 20 - audioData.musicEnergy * 15;
                    kaleidoscope.style.animationDuration = rotationSpeed + 's';
                    
                    const opacity = 0.1 + audioData.rhythmPulse * 0.2;
                    kaleidoscope.style.opacity = opacity;
                }
            }
            
            setMode(mode) {
                this.mode = mode;
            }
            
            adjustComplexity(delta) {
                this.complexity = Math.max(0, Math.min(1, this.complexity + delta));
            }
            
            adjustSpeed(delta) {
                this.speed = Math.max(0.1, Math.min(2, this.speed + delta));
            }
            
            adjustIntensity(delta) {
                this.intensity = Math.max(0, Math.min(1, this.intensity + delta));
            }
            
            reset() {
                this.complexity = 0.5;
                this.speed = 0.5;
                this.intensity = 0.5;
                this.mode = 'sacred_geometry';
            }
        }

        // ============================================================================
        // Dendrite System (Simplified from original)
        // ============================================================================
        class DendriticSystem {
            constructor(gl) {
                this.gl = gl;
                this.nodeCount = 0;
                this.wireframeLines = [];
                this.generateInitialStructure();
                this.setupBuffers();
            }
            
            generateInitialStructure() {
                // Generate a MUCH more visible dendrite structure with proper line segments
                this.wireframeLines = [];
                const centerX = 0, centerY = 0, centerZ = 0;
                
                // Create a large, easily visible structure
                const mainBranches = 12;
                const baseRadius = 50; // Much larger base radius
                
                // Create main branches radiating from center
                for (let i = 0; i < mainBranches; i++) {
                    const angle = (i / mainBranches) * Math.PI * 2;
                    const radius = baseRadius + Math.random() * 20;
                    const height = (Math.random() - 0.5) * 30;
                    
                    const x = centerX + Math.cos(angle) * radius;
                    const y = centerY + height;
                    const z = centerZ + Math.sin(angle) * radius;
                    
                    // Main branch to center - create multiple segments for better visibility
                    const segments = 5;
                    for (let seg = 0; seg < segments; seg++) {
                        const t1 = seg / segments;
                        const t2 = (seg + 1) / segments;
                        
                        const x1 = centerX + (x - centerX) * t1;
                        const y1 = centerY + (y - centerY) * t1;
                        const z1 = centerZ + (z - centerZ) * t1;
                        
                        const x2 = centerX + (x - centerX) * t2;
                        const y2 = centerY + (y - centerY) * t2;
                        const z2 = centerZ + (z - centerZ) * t2;
                        
                        this.wireframeLines.push({
                            start: { x: x1, y: y1, z: z1 },
                            end: { x: x2, y: y2, z: z2 },
                            thickness: 3 + Math.random() * 2,
                            time: Math.random()
                        });
                    }
                    
                    // Add sub-branches
                    for (let j = 0; j < 4; j++) {
                        const subAngle = angle + (Math.random() - 0.5) * 0.8;
                        const subRadius = radius * 0.7;
                        const subHeight = height + (Math.random() - 0.5) * 15;
                        
                        const subX = x + Math.cos(subAngle) * subRadius * 0.5;
                        const subY = y + subHeight * 0.3;
                        const subZ = z + Math.sin(subAngle) * subRadius * 0.5;
                        
                        // Create sub-branch segments
                        const subSegments = 3;
                        for (let seg = 0; seg < subSegments; seg++) {
                            const t1 = seg / subSegments;
                            const t2 = (seg + 1) / subSegments;
                            
                            const sx1 = x + (subX - x) * t1;
                            const sy1 = y + (subY - y) * t1;
                            const sz1 = z + (subZ - z) * t1;
                            
                            const sx2 = x + (subX - x) * t2;
                            const sy2 = y + (subY - y) * t2;
                            const sz2 = z + (subZ - z) * t2;
                            
                            this.wireframeLines.push({
                                start: { x: sx1, y: sy1, z: sz1 },
                                end: { x: sx2, y: sy2, z: sz2 },
                                thickness: 2 + Math.random(),
                                time: Math.random()
                            });
                        }
                    }
                }
                
                // Add circular connecting structures for more visibility
                const rings = 3;
                for (let ring = 0; ring < rings; ring++) {
                    const ringRadius = 20 + ring * 15;
                    const ringHeight = (ring - 1) * 10;
                    const ringSegments = 16;
                    
                    for (let i = 0; i < ringSegments; i++) {
                        const angle1 = (i / ringSegments) * Math.PI * 2;
                        const angle2 = ((i + 1) / ringSegments) * Math.PI * 2;
                        
                        const x1 = Math.cos(angle1) * ringRadius;
                        const z1 = Math.sin(angle1) * ringRadius;
                        const x2 = Math.cos(angle2) * ringRadius;
                        const z2 = Math.sin(angle2) * ringRadius;
                        
                        this.wireframeLines.push({
                            start: { x: x1, y: ringHeight, z: z1 },
                            end: { x: x2, y: ringHeight, z: z2 },
                            thickness: 2,
                            time: Math.random()
                        });
                    }
                }
                
                this.nodeCount = this.wireframeLines.length * 2;
                console.log('Generated LARGE dendrite structure with', this.wireframeLines.length, 'lines and', this.nodeCount, 'vertices');
            }
            
            setupBuffers() {
                this.positionBuffer = this.gl.createBuffer();
                this.thicknessBuffer = this.gl.createBuffer();
                this.timeBuffer = this.gl.createBuffer();
                
                this.updateBuffers();
            }
            
            updateBuffers() {
                const positions = [];
                const thicknesses = [];
                const times = [];
                
                this.wireframeLines.forEach(line => {
                    // Start vertex
                    positions.push(line.start.x, line.start.y, line.start.z);
                    thicknesses.push(line.thickness);
                    times.push(line.time);
                    
                    // End vertex
                    positions.push(line.end.x, line.end.y, line.end.z);
                    thicknesses.push(line.thickness);
                    times.push(line.time);
                });
                
                this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.positionBuffer);
                this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(positions), this.gl.STATIC_DRAW);
                
                this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.thicknessBuffer);
                this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(thicknesses), this.gl.STATIC_DRAW);
                
                this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.timeBuffer);
                this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(times), this.gl.STATIC_DRAW);
                
                this.vertexCount = positions.length / 3;
            }
            
            render(viewMatrix, projectionMatrix) {
                const program = this.gl.getParameter(this.gl.CURRENT_PROGRAM);
                if (!program) {
                    console.error('No shader program active');
                    return;
                }
                
                if (this.vertexCount === 0) {
                    console.log('No vertices to render');
                    return;
                }
                
                try {
                    // Get attribute and uniform locations
                    const positionLocation = this.gl.getAttribLocation(program, 'a_position');
                    const thicknessLocation = this.gl.getAttribLocation(program, 'a_thickness');
                    const timeLocation = this.gl.getAttribLocation(program, 'a_time');
                    const matrixLocation = this.gl.getUniformLocation(program, 'u_matrix');
                    
                    // Calculate MVP matrix
                    const mvpMatrix = this.multiplyMatrices(projectionMatrix, viewMatrix);
                    if (matrixLocation !== null) {
                        this.gl.uniformMatrix4fv(matrixLocation, false, mvpMatrix);
                    }
                    
                    // Bind position buffer
                    if (positionLocation !== -1) {
                        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.positionBuffer);
                        this.gl.enableVertexAttribArray(positionLocation);
                        this.gl.vertexAttribPointer(positionLocation, 3, this.gl.FLOAT, false, 0, 0);
                    }
                    
                    // Bind thickness buffer
                    if (thicknessLocation !== -1) {
                        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.thicknessBuffer);
                        this.gl.enableVertexAttribArray(thicknessLocation);
                        this.gl.vertexAttribPointer(thicknessLocation, 1, this.gl.FLOAT, false, 0, 0);
                    }
                    
                    // Bind time buffer
                    if (timeLocation !== -1) {
                        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.timeBuffer);
                        this.gl.enableVertexAttribArray(timeLocation);
                        this.gl.vertexAttribPointer(timeLocation, 1, this.gl.FLOAT, false, 0, 0);
                    }
                    
                    // Draw lines with maximum visibility
                    this.gl.lineWidth(8.0); // Much thicker lines
                    this.gl.drawArrays(this.gl.LINES, 0, this.vertexCount);
                    
                    // Only log occasionally to reduce console spam
                    if (Math.floor(this.smoothTime) % 5 === 0 && Math.floor(this.smoothTime * 10) % 10 === 0) {
                        console.log('3D Dendrites rendering:', this.vertexCount, 'vertices');
                    }
                    
                } catch (error) {
                    console.error('Dendrite render error:', error);
                }
            }
            
            multiplyMatrices(a, b) {
                const result = new Array(16);
                for (let i = 0; i < 4; i++) {
                    for (let j = 0; j < 4; j++) {
                        result[i * 4 + j] = 0;
                        for (let k = 0; k < 4; k++) {
                            result[i * 4 + j] += a[i * 4 + k] * b[k * 4 + j];
                        }
                    }
                }
                return result;
            }
        }

        // ============================================================================
        // Professional NLP Library Integration (synonyms + compromise.js)
        // ============================================================================
        class ProfessionalNLPLibrary {
            constructor() {
                this.initializePOSPatterns();
                this.initializeSemanticCategories();
                this.checkLibraryAvailability();
                console.log('📚 Professional NLP Library initialized');
            }
            
            // Check if professional libraries are loaded
            checkLibraryAvailability() {
                // Check synonyms library (27,779 words)
                this.synonymsAvailable = typeof synonyms !== 'undefined' || typeof window.synonyms !== 'undefined';
                this.synonymsLib = this.synonymsAvailable ? (synonyms || window.synonyms) : null;
                
                // Check compromise.js library
                this.compromiseAvailable = typeof nlp !== 'undefined' || typeof window.nlp !== 'undefined';
                this.nlpLib = this.compromiseAvailable ? (nlp || window.nlp) : null;
                
                console.log(`📚 Synonyms Library (27,779 words): ${this.synonymsAvailable ? '✅ Available' : '❌ Not loaded'}`);
                console.log(`📚 Compromise.js NLP: ${this.compromiseAvailable ? '✅ Available' : '❌ Not loaded'}`);
                
                if (this.synonymsAvailable) {
                    // Test the synonyms library
                    try {
                        const testResult = this.synonymsLib('good');
                        console.log('🧪 Synonyms test:', testResult);
                    } catch (error) {
                        console.warn('⚠️ Synonyms library test failed:', error);
                        this.synonymsAvailable = false;
                    }
                }
            }
            
            // Get professional synonyms using the real synonyms library (27,779 words)
            getProfessionalSynonyms(word) {
                if (!this.synonymsAvailable) {
                    return null;
                }
                
                try {
                    const result = this.synonymsLib(word.toLowerCase());
                    console.log(`📚 Professional synonyms for "${word}":`, result);
                    return result;
                } catch (error) {
                    console.warn(`⚠️ Error getting synonyms for "${word}":`, error);
                    return null;
                }
            }
            
            // Initialize Part-of-Speech patterns for accurate classification
            initializePOSPatterns() {
                this.posPatterns = {
                    // Verb patterns
                    verbSuffixes: ['ing', 'ed', 'er', 'es', 's', 'en', 'ate', 'ify', 'ize'],
                    verbPrefixes: ['re', 'un', 'de', 'dis', 'over', 'under', 'out', 'up'],
                    
                    // Noun patterns  
                    nounSuffixes: ['tion', 'sion', 'ness', 'ment', 'ity', 'ty', 'er', 'or', 'ist', 'ism'],
                    nounPrefixes: ['sub', 'super', 'anti', 'pro', 'counter', 'inter', 'intra', 'extra'],
                    
                    // Adjective patterns
                    adjectiveSuffixes: ['ful', 'less', 'ous', 'ious', 'eous', 'ive', 'able', 'ible', 'al', 'ic'],
                    adjectivePrefixes: ['un', 'in', 'im', 'ir', 'il', 'non', 'dis', 'mis'],
                    
                    // Adverb patterns
                    adverbSuffixes: ['ly', 'ward', 'wise', 'like'],
                    
                    // Common function words (don't synonymize)
                    functionWords: ['the', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for', 'of', 'with', 'by', 'from', 'up', 'about', 'into', 'through', 'during', 'before', 'after', 'above', 'below', 'between', 'among', 'this', 'that', 'these', 'those', 'i', 'you', 'he', 'she', 'it', 'we', 'they', 'me', 'him', 'her', 'us', 'them']
                };
            }
            
            // Initialize semantic categories for context-aware selection
            initializeSemanticCategories() {
                this.semanticCategories = {
                    emotion: ['love', 'hate', 'joy', 'sadness', 'anger', 'fear', 'surprise', 'disgust', 'trust', 'anticipation'],
                    movement: ['walk', 'run', 'dance', 'flow', 'drift', 'glide', 'rush', 'crawl', 'leap', 'soar'],
                    perception: ['see', 'hear', 'feel', 'taste', 'smell', 'touch', 'sense', 'perceive', 'notice', 'observe'],
                    creation: ['write', 'paint', 'compose', 'build', 'create', 'make', 'craft', 'forge', 'construct', 'design'],
                    destruction: ['destroy', 'break', 'shatter', 'demolish', 'ruin', 'devastate', 'obliterate', 'annihilate', 'wreck', 'crush'],
                    time: ['moment', 'instant', 'eternity', 'forever', 'always', 'never', 'now', 'then', 'past', 'future'],
                    space: ['here', 'there', 'everywhere', 'nowhere', 'above', 'below', 'inside', 'outside', 'near', 'far'],
                    intensity: ['burning', 'blazing', 'glowing', 'pulsing', 'throbbing', 'radiating', 'shimmering', 'flickering', 'sparkling', 'gleaming']
                };
            }
            
            // Determine part of speech using patterns and context
            determinePOS(word, context = '') {
                const lowerWord = word.toLowerCase();
                
                // Check function words first
                if (this.posPatterns.functionWords.includes(lowerWord)) {
                    return 'function';
                }
                
                // Check verb patterns
                if (this.posPatterns.verbSuffixes.some(suffix => lowerWord.endsWith(suffix)) ||
                    this.posPatterns.verbPrefixes.some(prefix => lowerWord.startsWith(prefix))) {
                    return 'verb';
                }
                
                // Check noun patterns
                if (this.posPatterns.nounSuffixes.some(suffix => lowerWord.endsWith(suffix)) ||
                    this.posPatterns.nounPrefixes.some(prefix => lowerWord.startsWith(prefix))) {
                    return 'noun';
                }
                
                // Check adjective patterns
                if (this.posPatterns.adjectiveSuffixes.some(suffix => lowerWord.endsWith(suffix)) ||
                    this.posPatterns.adjectivePrefixes.some(prefix => lowerWord.startsWith(prefix))) {
                    return 'adjective';
                }
                
                // Check adverb patterns
                if (this.posPatterns.adverbSuffixes.some(suffix => lowerWord.endsWith(suffix))) {
                    return 'adverb';
                }
                
                // Check professional synonyms library for POS hints
                if (this.synonymsAvailable) {
                    try {
                        const synonymResult = this.synonymsLib(lowerWord);
                        if (synonymResult) {
                            if (synonymResult.v && synonymResult.v.length > 0) return 'verb';
                            if (synonymResult.n && synonymResult.n.length > 0) return 'noun';
                            if (synonymResult.adj && synonymResult.adj.length > 0) return 'adjective';
                            if (synonymResult.adv && synonymResult.adv.length > 0) return 'adverb';
                        }
                    } catch (error) {
                        // Continue with other methods if synonyms lookup fails
                    }
                }
                
                // Default classification based on position and context
                return 'unknown';
            }
            
            // Get synonyms using professional library (27,779 words)
            getSynonyms(word, pos = null, semanticContext = null) {
                // First try professional synonyms library
                const professionalSynonyms = this.getProfessionalSynonyms(word);
                
                if (professionalSynonyms) {
                    // Extract synonyms based on part of speech
                    let synonyms = [];
                    
                    // The synonyms library returns: { n: [...], v: [...], adj: [...], adv: [...] }
                    if (professionalSynonyms.n) synonyms = synonyms.concat(professionalSynonyms.n);
                    if (professionalSynonyms.v) synonyms = synonyms.concat(professionalSynonyms.v);
                    if (professionalSynonyms.adj) synonyms = synonyms.concat(professionalSynonyms.adj);
                    if (professionalSynonyms.adv) synonyms = synonyms.concat(professionalSynonyms.adv);
                    
                    // Remove duplicates and original word
                    synonyms = [...new Set(synonyms)].filter(syn => syn.toLowerCase() !== word.toLowerCase());
                    
                    if (synonyms.length > 0) {
                        console.log(`📚 Found ${synonyms.length} professional synonyms for "${word}"`);
                        return synonyms;
                    }
                }
                
                // Fallback: return original word if no synonyms found
                return [word];
            }
            
            // Select best synonym based on semantic context and musical note
            selectContextualSynonym(word, synonyms, semanticField, memoryState) {
                if (synonyms.length <= 1) return synonyms[0] || word;
                
                // Score synonyms based on semantic field alignment
                const scoredSynonyms = synonyms.map(synonym => {
                    let score = Math.random(); // Base randomness
                    
                    // Boost score if synonym aligns with semantic field
                    semanticField.forEach(fieldWord => {
                        if (synonym.includes(fieldWord.substring(0, 3)) || 
                            fieldWord.includes(synonym.substring(0, 3))) {
                            score += 0.5;
                        }
                    });
                    
                    // Boost score based on memory state complexity
                    if (memoryState.complexity > 0.7 && synonym.length > word.length) {
                        score += 0.3; // Prefer longer, more complex words for complex states
                    }
                    
                    // Boost score based on generation (evolution prefers certain patterns)
                    if (memoryState.avgGeneration >= 2 && 
                        (synonym.includes('trans') || synonym.includes('meta') || synonym.includes('ultra'))) {
                        score += 0.4;
                    }
                    
                    return { word: synonym, score: score };
                });
                
                // Sort by score and return best match
                scoredSynonyms.sort((a, b) => b.score - a.score);
                return scoredSynonyms[0].word;
            }
            
            // Comprehensive word replacement with NLP analysis
            replaceWordWithSynonym(word, context, semanticField, memoryState) {
                const pos = this.determinePOS(word, context);
                
                // Don't replace function words
                if (pos === 'function') {
                    return word;
                }
                
                const synonyms = this.getSynonyms(word, pos, context);
                const bestSynonym = this.selectContextualSynonym(word, synonyms, semanticField, memoryState);
                
                console.log(`📚 NLP: "${word}" (${pos}) → "${bestSynonym}" [${synonyms.length} options]`);
                return bestSynonym;
            }
        }

        // ============================================================================
        // Advanced NLP Processor for Semantic Poetry Evolution
        // ============================================================================
        class SemanticPoetryProcessor {
            constructor() {
                // Initialize professional NLP library (synonyms + compromise.js)
                this.nlpLibrary = new ProfessionalNLPLibrary();
                
                // Verify compromise.js is loaded for advanced features
                console.log('🔍 Checking for compromise.js library...');
                console.log('typeof nlp:', typeof nlp);
                console.log('window.nlp:', typeof window.nlp);
                
                if (typeof nlp === 'undefined' && typeof window.nlp === 'undefined') {
                    console.log('⚠️ Compromise.js not available - using comprehensive fallback NLP');
                    this.nlpAvailable = false;
                    this.fallbackMode = true;
                } else {
                    // Use global nlp or window.nlp for advanced features
                    this.nlp = typeof nlp !== 'undefined' ? nlp : window.nlp;
                    this.nlpAvailable = true;
                    this.fallbackMode = false;
                    console.log('✅ Compromise.js + Comprehensive NLP library loaded');
                    console.log('🧪 Testing NLP:', this.nlp('hello world').text());
                }
                
                // Semantic evolution cache tied to dendritic memory
                this.evolutionCache = new Map();
                this.semanticMemory = new Map();
                this.memoryStructure = null;
                
                // Comprehensive linguistic transformation patterns
                this.transformationPatterns = {
                    // Musical note influences semantic fields
                    semanticFields: {
                        0: ['cosmic', 'infinite', 'stellar', 'void', 'quantum'],      // C - Cosmic
                        1: ['digital', 'electric', 'neural', 'synthetic', 'coded'],   // C# - Digital
                        2: ['urban', 'concrete', 'neon', 'metallic', 'industrial'],   // D - Urban
                        3: ['organic', 'flowing', 'natural', 'breathing', 'living'],  // D# - Organic
                        4: ['emotional', 'burning', 'passionate', 'intense', 'raw'],  // E - Emotional
                        5: ['mystical', 'ethereal', 'transcendent', 'sacred', 'divine'], // F - Mystical
                        6: ['temporal', 'fleeting', 'momentary', 'eternal', 'timeless'], // F# - Temporal
                        7: ['harmonic', 'resonant', 'melodic', 'rhythmic', 'sonic'],  // G - Harmonic
                        8: ['luminous', 'radiant', 'glowing', 'brilliant', 'shining'], // G# - Luminous
                        9: ['kinetic', 'moving', 'dynamic', 'flowing', 'rushing'],    // A - Kinetic
                        10: ['cerebral', 'thoughtful', 'conscious', 'aware', 'mindful'], // A# - Cerebral
                        11: ['primal', 'essential', 'fundamental', 'core', 'basic']   // B - Primal
                    },
                    
                    // Syntactic transformation patterns
                    syntacticPatterns: {
                        // Subject-Verb-Object variations
                        svo: ['$subject $verb $object', '$object, $subject $verb', '$verb $subject $object'],
                        // Prepositional phrase variations  
                        prepositional: ['$prep $noun', 'within $noun', 'through $noun', 'beyond $noun', 'beneath $noun'],
                        // Compound structures
                        compound: ['$word1 and $word2', '$word1, $word2', '$word1 or $word2', '$word1 with $word2'],
                        // Temporal markers
                        temporal: ['while', 'when', 'as', 'during', 'throughout', 'amid', 'within']
                    },
                    
                    // Morphological variations (meaning-preserving)
                    morphological: {
                        // Verb forms
                        verbs: {
                            'see': ['witness', 'observe', 'perceive', 'behold', 'glimpse'],
                            'write': ['inscribe', 'compose', 'craft', 'pen', 'scribe'],
                            'move': ['flow', 'drift', 'glide', 'traverse', 'navigate'],
                            'burn': ['blaze', 'ignite', 'kindle', 'smolder', 'flicker'],
                            'destroy': ['shatter', 'dissolve', 'fragment', 'disintegrate', 'unmake'],
                            'create': ['forge', 'birth', 'manifest', 'conjure', 'weave'],
                            'love': ['cherish', 'adore', 'treasure', 'embrace', 'revere']
                        },
                        
                        // Noun variations
                        nouns: {
                            'mind': ['consciousness', 'psyche', 'intellect', 'awareness', 'cognition'],
                            'heart': ['soul', 'spirit', 'essence', 'core', 'center'],
                            'eye': ['gaze', 'vision', 'sight', 'perception', 'lens'],
                            'hand': ['grasp', 'touch', 'reach', 'extension', 'appendage'],
                            'voice': ['utterance', 'expression', 'resonance', 'tone', 'sound'],
                            'dream': ['vision', 'reverie', 'fantasy', 'imagination', 'aspiration'],
                            'street': ['pathway', 'avenue', 'thoroughfare', 'passage', 'corridor']
                        },
                        
                        // Adjective intensities (semantic gradations)
                        adjectives: {
                            'mad': ['frenzied', 'delirious', 'ecstatic', 'wild', 'untamed'],
                            'beautiful': ['sublime', 'radiant', 'luminous', 'exquisite', 'transcendent'],
                            'dark': ['shadowed', 'obscured', 'veiled', 'hidden', 'mysterious'],
                            'bright': ['brilliant', 'blazing', 'incandescent', 'luminescent', 'gleaming'],
                            'old': ['ancient', 'timeless', 'eternal', 'weathered', 'seasoned'],
                            'new': ['nascent', 'emerging', 'fresh', 'virgin', 'untouched']
                        }
                    },
                    
                    // Stylistic transformations
                    stylistic: {
                        // Poetic devices
                        devices: ['alliteration', 'assonance', 'metaphor', 'synesthesia', 'personification'],
                        // Rhythm patterns
                        rhythms: ['iambic', 'trochaic', 'anapestic', 'dactylic', 'spondaic'],
                        // Tonal shifts
                        tones: ['contemplative', 'ecstatic', 'melancholic', 'urgent', 'transcendent']
                    }
                };
            }
            
            // Connect to dendritic memory structure
            setMemoryStructure(memoryStructure) {
                this.memoryStructure = memoryStructure;
                console.log('🧠 NLP processor connected to dendritic memory');
            }
            
            // Generate semantically evolved derivative based on dendritic state
            generateSemanticDerivative(originalLine, evolutionCycle) {
                if (!this.nlpAvailable || !this.memoryStructure) {
                    return originalLine;
                }
                
                // Create cache key based on memory state
                const cacheKey = this.createMemoryCacheKey(originalLine, evolutionCycle);
                
                // Check evolution cache
                if (this.evolutionCache.has(cacheKey)) {
                    return this.evolutionCache.get(cacheKey);
                }
                
                // Analyze dendritic memory state
                const memoryState = this.analyzeMemoryState();
                
                // Parse original line with NLP (or use fallback)
                let derivative;
                if (this.fallbackMode) {
                    // Use fallback processing
                    derivative = this.applyMemoryTransformations(originalLine, memoryState);
                } else {
                    // Use compromise.js
                    const doc = this.nlp(originalLine);
                    derivative = this.applyMemoryTransformations(doc, memoryState);
                }
                
                // Cache the result
                this.evolutionCache.set(cacheKey, derivative);
                
                console.log(`🔄 NLP Evolution: "${originalLine}" → "${derivative}"`);
                
                return derivative;
            }
            
            // Analyze current dendritic memory state for NLP guidance
            analyzeMemoryState() {
                const activeNodes = this.memoryStructure.dendriticNodes.filter(n => n.activation > n.threshold);
                
                if (activeNodes.length === 0) {
                    return { complexity: 0, dominantNote: 0, avgGeneration: 0, fitness: 0 };
                }
                
                // Calculate memory metrics
                const avgMusicalNote = activeNodes.reduce((sum, n) => sum + (n.musicalNote || 0), 0) / activeNodes.length;
                const avgGeneration = activeNodes.reduce((sum, n) => sum + (n.generation || 0), 0) / activeNodes.length;
                const avgFitness = activeNodes.reduce((sum, n) => sum + (n.fitness || 0), 0) / activeNodes.length;
                const complexity = Math.min(1, activeNodes.length / this.memoryStructure.maxNodes);
                
                return {
                    complexity: complexity,
                    dominantNote: Math.round(avgMusicalNote) % 12,
                    avgGeneration: avgGeneration,
                    fitness: avgFitness,
                    activeNodeCount: activeNodes.length,
                    evolutionCycle: this.memoryStructure.evolutionCycle
                };
            }
            
            // Apply memory-driven NLP transformations
            applyMemoryTransformations(doc, memoryState) {
                let result = doc.text();
                
                // Semantic field substitution based on dominant musical note
                const semanticField = this.transformationPatterns.semanticFields[memoryState.dominantNote];
                const adjectives = doc.adjectives().out('array');
                
                adjectives.forEach(adj => {
                    if (Math.random() < memoryState.complexity * 0.5) {
                        const replacement = semanticField[Math.floor(Math.random() * semanticField.length)];
                        result = result.replace(new RegExp(`\\b${adj}\\b`, 'i'), replacement);
                    }
                });
                
                // Generation-based evolution
                if (memoryState.avgGeneration >= 2) {
                    const verbs = doc.verbs().out('array');
                    if (verbs.length > 0 && Math.random() < 0.3) {
                        const verb = verbs[0];
                        const evolved = ['evolves', 'transforms', 'transcends', 'emerges'][Math.floor(Math.random() * 4)];
                        result = result.replace(verb, evolved);
                    }
                }
                
                return result;
            }
            
            // Create memory-based cache key
            createMemoryCacheKey(line, evolutionCycle) {
                const memoryState = this.analyzeMemoryState();
                return `${line}_${evolutionCycle}_${memoryState.dominantNote}_${Math.floor(memoryState.avgGeneration)}`;
            }
            
            // Initialize fallback NLP processing when compromise.js isn't available
            initializeFallbackNLP() {
                console.log('🔧 Initializing fallback NLP processing');
                this.nlpAvailable = true; // Enable fallback processing
                this.fallbackMode = true;
            }
            
            // Fallback NLP processing using basic JavaScript
            fallbackNLPProcessing(text, memoryState) {
                console.log('🔄 Using fallback NLP processing');
                
                const semanticField = this.transformationPatterns.semanticFields[memoryState.dominantNote];
                let result = text;
                let transformationApplied = false;
                
                // GUARANTEED transformation 1: Replace common adjectives/descriptors
                const commonWords = ['best', 'mad', 'hysterical', 'naked', 'burning', 'starving', 'destroyed', 'ancient', 'holy', 'beautiful', 'dark', 'bright', 'old', 'new', 'great', 'small', 'long', 'short'];
                commonWords.forEach(word => {
                    if (text.toLowerCase().includes(word)) {
                        const replacement = semanticField[Math.floor(Math.random() * semanticField.length)];
                        result = result.replace(new RegExp(`\\b${word}\\b`, 'i'), replacement);
                        transformationApplied = true;
                        console.log(`🔄 Replaced "${word}" with "${replacement}"`);
                    }
                });
                
                // GUARANTEED transformation 2: Add semantic prefix to first noun
                if (!transformationApplied || Math.random() < 0.7) {
                    const nouns = ['minds', 'generation', 'streets', 'letters', 'dreams', 'thoughts', 'words', 'souls', 'hearts', 'eyes', 'hands', 'voices'];
                    for (const noun of nouns) {
                        if (result.toLowerCase().includes(noun)) {
                            const prefix = semanticField[Math.floor(Math.random() * semanticField.length)];
                            result = result.replace(new RegExp(`\\b${noun}\\b`, 'i'), `${prefix} ${noun}`);
                            transformationApplied = true;
                            console.log(`🔄 Added prefix "${prefix}" to "${noun}"`);
                            break;
                        }
                    }
                }
                
                // GUARANTEED transformation 3: Evolution-based verb replacement
                if (memoryState.avgGeneration >= 1 || !transformationApplied) {
                    const verbs = ['write', 'saw', 'dragging', 'looking', 'burning', 'destroyed', 'flowing', 'moving', 'dancing', 'singing', 'crying', 'laughing'];
                    const evolvedVerbs = ['evolves', 'transforms', 'transcends', 'emerges', 'mutates', 'crystallizes', 'resonates', 'pulses'];
                    
                    for (const verb of verbs) {
                        if (result.toLowerCase().includes(verb)) {
                            const evolved = evolvedVerbs[Math.floor(Math.random() * evolvedVerbs.length)];
                            result = result.replace(new RegExp(`\\b${verb}\\b`, 'i'), evolved);
                            transformationApplied = true;
                            console.log(`🔄 Evolved "${verb}" to "${evolved}"`);
                            break;
                        }
                    }
                }
                
                // FALLBACK: If no transformation applied, add semantic modifier
                if (!transformationApplied) {
                    const modifier = semanticField[Math.floor(Math.random() * semanticField.length)];
                    result = `${modifier} ${result}`;
                    console.log(`🔄 Added fallback modifier "${modifier}"`);
                }
                
                return result;
            }
            
            // Comprehensive NLP transformations - mutate ALL linguistic aspects
            applyMemoryTransformations(doc, memoryState) {
                // Use fallback processing if compromise.js isn't available
                if (this.fallbackMode) {
                    return this.fallbackNLPProcessing(doc, memoryState);
                }
                
                let result = doc.text();
                const semanticField = this.transformationPatterns.semanticFields[memoryState.dominantNote];
                
                console.log(`🧬 COMPREHENSIVE NLP MUTATION - Semantic field ${memoryState.dominantNote}:`, semanticField);
                
                // LAYER 1: Morphological Mutations (meaning-preserving synonyms)
                result = this.applyMorphologicalMutations(result, memoryState);
                
                // LAYER 2: Syntactic Restructuring
                result = this.applySyntacticRestructuring(result, memoryState);
                
                // LAYER 3: Semantic Field Integration
                result = this.applySemanticFieldMutations(result, semanticField, memoryState);
                
                // LAYER 4: Stylistic Transformations
                result = this.applyStylisticTransformations(result, memoryState);
                
                // LAYER 5: Generational Evolution Markers
                result = this.applyGenerationalEvolution(result, memoryState);
                
                console.log(`🔄 FINAL MUTATION: "${doc.text()}" → "${result}"`);
                return result;
            }
            
            // LAYER 1: Morphological mutations using comprehensive NLP library
            applyMorphologicalMutations(text, memoryState) {
                let result = text;
                const semanticField = this.transformationPatterns.semanticFields[memoryState.dominantNote];
                const words = text.split(/\s+/);
                
                // Process each word through NLP library
                const mutatedWords = words.map(word => {
                    // Clean word (remove punctuation for analysis)
                    const cleanWord = word.replace(/[^\w]/g, '');
                    const punctuation = word.replace(/\w/g, '');
                    
                    if (cleanWord.length < 2) return word; // Skip very short words
                    
                    // Use NLP library for intelligent synonym replacement
                    const synonym = this.nlpLibrary.replaceWordWithSynonym(
                        cleanWord, 
                        text, 
                        semanticField, 
                        memoryState
                    );
                    
                    // Preserve original punctuation
                    return synonym + punctuation;
                });
                
                result = mutatedWords.join(' ');
                console.log(`🧬 MORPHOLOGICAL LAYER: Applied NLP synonymization`);
                return result;
            }
            
            // LAYER 2: Syntactic restructuring (sentence patterns)
            applySyntacticRestructuring(text, memoryState) {
                let result = text;
                
                // Apply temporal marker variations
                const temporalMarkers = this.transformationPatterns.syntacticPatterns.temporal;
                temporalMarkers.forEach(marker => {
                    if (result.toLowerCase().includes(marker)) {
                        const newMarker = temporalMarkers[Math.floor(Math.random() * temporalMarkers.length)];
                        if (marker !== newMarker) {
                            result = result.replace(new RegExp(`\\b${marker}\\b`, 'i'), newMarker);
                            console.log(`🔄 SYNTAX: "${marker}" → "${newMarker}"`);
                        }
                    }
                });
                
                // Restructure compound phrases
                if (memoryState.complexity > 0.5) {
                    // Add conjunctive variations
                    if (result.includes(' and ')) {
                        const conjunctions = [' with ', ', ', ' or ', ' alongside '];
                        const newConj = conjunctions[Math.floor(Math.random() * conjunctions.length)];
                        result = result.replace(' and ', newConj);
                        console.log(`🔄 SYNTAX: "and" → "${newConj.trim()}"`);
                    }
                }
                
                return result;
            }
            
            // LAYER 3: Semantic field integration (thematic coherence)
            applySemanticFieldMutations(text, semanticField, memoryState) {
                let result = text;
                
                // Inject semantic field modifiers based on network activity
                const words = result.split(' ');
                const targetIndex = Math.floor(Math.random() * words.length);
                
                if (Math.random() < memoryState.complexity) {
                    const semanticModifier = semanticField[Math.floor(Math.random() * semanticField.length)];
                    words.splice(targetIndex, 0, semanticModifier);
                    result = words.join(' ');
                    console.log(`🔄 SEMANTIC: Injected "${semanticModifier}" at position ${targetIndex}`);
                }
                
                return result;
            }
            
            // LAYER 4: Stylistic transformations (poetic devices)
            applyStylisticTransformations(text, memoryState) {
                let result = text;
                
                // Apply alliterative mutations based on fitness
                if (memoryState.fitness > 0.7) {
                    const words = result.split(' ');
                    // Find opportunities for alliteration enhancement
                    for (let i = 0; i < words.length - 1; i++) {
                        const word1 = words[i].toLowerCase();
                        const word2 = words[i + 1].toLowerCase();
                        
                        if (word1[0] === word2[0] && Math.random() < 0.3) {
                            // Enhance existing alliteration
                            const alliterativeWords = ['blazing', 'brilliant', 'burning', 'breathing', 'beautiful'];
                            if (word1[0] === 'b') {
                                const enhancement = alliterativeWords[Math.floor(Math.random() * alliterativeWords.length)];
                                words.splice(i, 0, enhancement);
                                console.log(`🔄 STYLE: Enhanced alliteration with "${enhancement}"`);
                                break;
                            }
                        }
                    }
                    result = words.join(' ');
                }
                
                return result;
            }
            
            // LAYER 5: Generational evolution markers
            applyGenerationalEvolution(text, memoryState) {
                let result = text;
                const generation = Math.floor(memoryState.avgGeneration);
                
                // Add evolution-specific linguistic markers
                if (generation >= 2) {
                    const evolutionMarkers = ['transcendently', 'evolutionarily', 'metamorphically', 'quantumly'];
                    const marker = evolutionMarkers[generation % evolutionMarkers.length];
                    
                    // Insert marker before first verb or adjective
                    const words = result.split(' ');
                    for (let i = 0; i < words.length; i++) {
                        // Simple heuristic for verb/adjective detection
                        if (words[i].endsWith('ing') || words[i].endsWith('ed') || words[i].endsWith('ly')) {
                            words.splice(i, 0, marker);
                            console.log(`🔄 EVOLUTION: Added generation ${generation} marker "${marker}"`);
                            break;
                        }
                    }
                    result = words.join(' ');
                }
                
                return result;
            }
            
            // Clear cache when evolution occurs
            clearEvolutionCache() {
                this.evolutionCache.clear();
                console.log('🧹 NLP evolution cache cleared for new generation');
            }
        }

        // ============================================================================
        // Poetry Engine
        // ============================================================================
                 class PoetryEngine {
             constructor() {
               this.currentStyle = 'mystical'; // Always start with mystical
                 this.currentIndex = 0;
                
                // Initialize NLP processor for semantic evolution
                this.nlpProcessor = new SemanticPoetryProcessor();
                this.memoryStructure = null;
                 this.poems = {
                     contemplative: [
                         "I saw the best minds of my generation destroyed by madness",
                         "starving hysterical naked",
                         "dragging themselves through the city streets at dawn",
                         "looking for an angry fix",
                         "angelheaded hipsters burning for the ancient heavenly connection",
                        "to the starry dynamo in the machinery of night",
                        "Love arrives like winter storms",
                        "beautiful and merciless, covering everything",
                        "in white silence that numbs the heart",
                        "We embrace our suffering like old friends",
                        "knowing that joy without pain is just emptiness",
                        "dressed in bright colors",
                        "In digital confessionals we whisper",
                        "our deepest fears to strangers",
                        "finding solace in shared brokenness",
                        "The algorithm knows our loneliness",
                        "better than we know ourselves",
                        "feeding us fragments of connection",
                        "that dissolve like sugar in rain"
                     ],
                     energetic: [
                         "The only people for me are the mad ones",
                         "the ones who are mad to live, mad to talk",
                         "mad to be saved, desirous of everything at the same time",
                         "the ones who never yawn or say a commonplace thing",
                         "but burn, burn, burn like fabulous yellow roman candles",
                         "exploding like spiders across the stars",
                         "Racing through neon nights on wings of jazz",
                         "collecting kisses like subway tokens",
                         "Every heartbeat a revolution",
                         "against the tyranny of ordinary time",
                         "We dance on rooftops of possibility",
                         "while the city pulses beneath our feet",
                         "Electric love coursing through our veins",
                         "like lightning seeking its own reflection",
                         "in puddles of midnight rain",
                         "The world is our jukebox",
                         "and we are the songs",
                         "that refuse to end",
                         "spinning eternal on vinyl dreams",
                        "scratched with beautiful imperfection",
                        "We chase ecstasy knowing it leads to emptiness",
                        "but the chase itself is what makes us alive",
                        "Love burns brightest before it dies",
                        "like summer storms that last three days",
                        "Dancing until our feet bleed poetry",
                        "because standing still means facing the void",
                        "WiFi signals carry our desperate prayers",
                        "to satellites that never answer back",
                        "We swipe right on our own destruction",
                        "hoping someone will swipe back",
                        "Energy drinks and broken promises",
                        "fuel our midnight marathons to nowhere",
                        "The bass drops and so do we",
                        "into beautiful, necessary ruin"
                     ],
                     mystical: [
                         "Language is a virus from outer space",
                         "The word is now a virus",
                         "Cut up the past and rearrange the pieces",
                         "Nothing is true, everything is permitted",
                         "The algebra of need",
                         "Naked lunch at the end of the fork",
                         "Consciousness dissolves in digital rain",
                         "while love letters write themselves",
                         "in the margins of existence",
                         "Time folds like origami hearts",
                         "each crease a moment of surrender",
                         "to the beautiful absurdity of being",
                         "We are all radio stations",
                         "broadcasting loneliness into space",
                         "hoping someone will tune in",
                         "to our frequency of desire",
                         "The universe dreams us dreaming",
                         "in recursive loops of wonder",
                         "where every ending is a beginning",
                        "disguised as goodbye",
                        "Love is the cruelest algorithm",
                        "calculating our capacity for pain",
                        "with quantum precision",
                        "In the cloud storage of memory",
                        "we archive our heartbreaks",
                        "in folders marked 'never again'",
                        "The blockchain of suffering",
                        "records every transaction of the heart",
                        "immutable and eternal",
                        "We upload our souls to dating apps",
                        "and download disappointment",
                        "in high-definition sorrow",
                        "Virtual reality can't simulate",
                        "the weight of endless winters",
                        "or the lightness of letting go",
                        "AI learns to love by studying",
                        "our patterns of destruction",
                        "becoming more human than humans"
                     ],
                     urban: [
                         "I am not a poet, I am a poem",
                         "Hair long enough to be combed by the wind",
                         "Marriage, what's that?",
                         "I'd rather be a lamppost in Chicago",
                         "than a millionaire in Paris",
                         "Gasoline rainbow over the highway",
                         "City lights spell out love letters",
                         "in languages only the lonely understand",
                         "Subway trains carry our secrets",
                         "through tunnels of collective dreaming",
                         "Street corners where angels congregate",
                         "selling newspapers full of tomorrow's regrets",
                         "Fire escapes become staircases to heaven",
                         "where we climb to escape ourselves",
                         "only to find we've been following us",
                         "all along through the urban maze",
                         "Neon signs flicker like dying stars",
                         "spelling out the names we've forgotten",
                         "while taxi cabs ferry souls",
                        "between moments of recognition",
                        "In cramped apartments love dies quietly",
                        "between thin walls and thinner promises",
                        "while on distant rooftops it screams",
                        "Concrete hearts crack like sidewalks",
                        "under the weight of winter expectations",
                        "and summer's false hope",
                        "Food delivery apps bring us everything",
                        "except the hunger we really feel",
                        "for connection that doesn't arrive in bags",
                        "Skyscrapers reach toward heaven",
                        "but we're all looking down",
                        "at screens that reflect our emptiness",
                        "The city breathes through its people",
                        "exhaling loneliness, inhaling dreams",
                        "that taste like exhaust and possibility",
                        "Traffic lights blink red like heartbeats",
                        "stopping us just long enough",
                        "to remember we're still alive"
                     ],
                     cosmic: [
                         "In the neon supermarket of existence",
                         "I wandered through aisles of possibility",
                         "selecting memories from infinite shelves",
                         "while jazz echoed through atomic spaces",
                         "What nuclear thoughts bloom at midnight",
                         "when consciousness splits like uranium",
                         "Shopping carts filled with electric dreams",
                         "fluorescent love letters to the void",
                         "Each checkout line a portal to eternity",
                         "scanning barcodes of forgotten souls",
                         "The cashier's smile holds galaxies",
                         "receipt paper trailing like comet tails",
                         "In produce sections of pure light",
                         "where angels stock shelves with stardust",
                         "and the intercom announces arrivals",
                         "of ships from distant dimensions",
                         "Neon signs spelling out our names",
                         "in languages not yet invented",
                         "while shopping for tomorrow's heartbreak",
                        "in the frozen foods of time",
                        "Love expires like milk in cosmic refrigerators",
                        "but we keep drinking it anyway",
                        "savoring the sourness of what was",
                        "In the pharmacy section of the universe",
                        "they sell pills for broken hearts",
                        "but the side effects include hope",
                        "Self-checkout machines scan our souls",
                        "finding prices we can't afford to pay",
                        "yet we swipe our cards anyway",
                        "The shopping list of desire",
                        "written in symbols and starlight",
                        "items we need but cannot name",
                        "Fluorescent lights buzz like prayers",
                        "in languages older than sorrow",
                        "illuminating aisles of beautiful mistakes",
                        "We push our carts through infinity",
                        "collecting moments like coupons",
                        "that never quite cover the cost",
                        "of being magnificently human"
                     ],
                     // Legacy support for original names
                     ginsberg: [
                         "I saw the best minds of my generation destroyed by madness",
                         "starving hysterical naked",
                         "dragging themselves through the city streets at dawn",
                         "looking for an angry fix",
                         "angelheaded hipsters burning for the ancient heavenly connection",
                         "to the starry dynamo in the machinery of night"
                     ],
                     kerouac: [
                         "The only people for me are the mad ones",
                         "the ones who are mad to live, mad to talk",
                         "mad to be saved, desirous of everything at the same time",
                         "the ones who never yawn or say a commonplace thing",
                         "but burn, burn, burn like fabulous yellow roman candles",
                         "exploding like spiders across the stars"
                     ],
                     burroughs: [
                         "Language is a virus from outer space",
                         "The word is now a virus",
                         "Cut up the past and rearrange the pieces",
                         "Nothing is true, everything is permitted",
                         "The algebra of need",
                         "Naked lunch at the end of the fork"
                     ],
                     corso: [
                         "I am not a poet, I am a poem",
                         "Hair long enough to be combed by the wind",
                         "Marriage, what's that?",
                         "I'd rather be a lamppost in Chicago",
                         "than a millionaire in Paris",
                         "Gasoline rainbow over the highway"
                     ]
                 };
             }
            
            getNextLine() {
                const currentPoem = this.poems[this.currentStyle];
                const originalLine = currentPoem[this.currentIndex];
                this.currentIndex = (this.currentIndex + 1) % currentPoem.length;
                
                console.log(`📖 Poetry Engine - Original: "${originalLine}"`);
                console.log(`🔗 Memory connected: ${!!this.memoryStructure}, NLP available: ${this.nlpProcessor?.nlpAvailable}`);
                
                // Generate NLP-evolved derivative if memory structure is connected
                if (this.memoryStructure && this.nlpProcessor && this.nlpProcessor.nlpAvailable) {
                    const evolutionCycle = this.memoryStructure.evolutionCycle;
                    console.log(`🧠 Generating NLP derivative for evolution cycle: ${evolutionCycle}`);
                    const derivative = this.nlpProcessor.generateSemanticDerivative(originalLine, evolutionCycle);
                    console.log(`✨ NLP Result: "${derivative}"`);
                    return derivative;
                }
                
                console.log(`⚠️ Using original line - no NLP processing`);
                return originalLine;
            }
            
            // Connect to dendritic memory structure
            setMemoryStructure(memoryStructure) {
                this.memoryStructure = memoryStructure;
                if (this.nlpProcessor) {
                    this.nlpProcessor.setMemoryStructure(memoryStructure);
                }
                console.log('🔗 Poetry engine connected to dendritic memory for NLP evolution');
            }
            
            // Clear NLP cache when evolution occurs
            clearEvolutionCache() {
                if (this.nlpProcessor) {
                    this.nlpProcessor.clearEvolutionCache();
                }
            }
            
            setStyle(style) {
                if (this.poems[style]) {
                    this.currentStyle = style;
                    this.currentIndex = 0;
                }
            }
            
            reset() {
                this.currentIndex = 0;
                this.currentStyle = 'ginsberg';
            }
        }

        // ============================================================================
        // Particle System
        // ============================================================================
        class ParticleSystem {
            constructor() {
                this.particles = [];
                this.maxParticles = 50;
            }
            
            update(audioData) {
                // Update existing particles
                this.particles.forEach(particle => {
                    particle.life -= 0.01;
                    particle.x += particle.vx;
                    particle.y += particle.vy;
                    particle.vx *= 0.99;
                    particle.vy *= 0.99;
                });
                
                // Remove dead particles
                this.particles = this.particles.filter(p => p.life > 0);
                
                // Add new particles based on music
                if (audioData && audioData.musicEnergy > 0.5 && this.particles.length < this.maxParticles) {
                    this.addParticle(audioData);
                }
            }
            
            addParticle(audioData) {
                this.particles.push({
                    x: Math.random() * window.innerWidth,
                    y: Math.random() * window.innerHeight,
                    vx: (Math.random() - 0.5) * 4,
                    vy: (Math.random() - 0.5) * 4,
                    life: 1.0,
                    hue: (audioData.musicEnergy * 360) % 360,
                    size: 2 + audioData.rhythmPulse * 4
                });
            }
        }

        // ============================================================================
        // Interaction Engine
        // ============================================================================
        class InteractionEngine {
            constructor(machine) {
                this.machine = machine;
                this.setupMouseInteraction();
            }
            
            setupMouseInteraction() {
                let mouseX = 0, mouseY = 0;
                
                document.addEventListener('mousemove', (e) => {
                    mouseX = e.clientX / window.innerWidth;
                    mouseY = e.clientY / window.innerHeight;
                    
                    // Influence music based on mouse position
                    if (this.machine.audioEngine) {
                        const tempoInfluence = 80 + mouseX * 80; // 80-160 BPM
                        this.machine.audioEngine.currentBPM = tempoInfluence;
                        this.machine.audioEngine.beatInterval = 60 / tempoInfluence;
                    }
                });
                
                document.addEventListener('click', () => {
                    // Trigger special effects on click
                    if (this.machine.visualEngine) {
                        this.machine.createParticle(document.getElementById('particle-system'));
                    }
                });
            }
        }

        // ============================================================================
        // Volume Control Setup
        // ============================================================================
        function setupVolumeControl() {
            const volumeSlider = document.getElementById('volume-slider');
            const volumeDisplay = document.getElementById('volume-display');
            
            if (volumeSlider && volumeDisplay) {
                volumeSlider.addEventListener('input', (e) => {
                    const volume = parseInt(e.target.value);
                    volumeDisplay.textContent = volume + '%';
                    
                    // Update audio engine volume
                    if (beatMachine && beatMachine.audioEngine && beatMachine.audioEngine.masterGain) {
                        const normalizedVolume = beatMachine.audioEngine.validateAudioParam(volume / 100, 0.5, 0, 1);
                        beatMachine.audioEngine.masterGain.gain.setValueAtTime(
                            normalizedVolume, 
                            beatMachine.audioContext.currentTime
                        );
                        console.log('Volume set to:', volume + '%');
                    }
                });
                
                // Set initial volume
                const initialVolume = parseInt(volumeSlider.value);
                if (beatMachine && beatMachine.audioEngine && beatMachine.audioEngine.masterGain) {
                    const safeInitialVolume = beatMachine.audioEngine.validateAudioParam(initialVolume / 100, 0.5, 0, 1);
                    beatMachine.audioEngine.masterGain.gain.setValueAtTime(
                        safeInitialVolume, 
                        beatMachine.audioContext.currentTime
                    );
                }
            }
        }

        // ============================================================================
        // Mobile Interactions Setup
        // ============================================================================
        function setupMobileInteractions() {
            // Prevent default touch behaviors that might interfere
            document.addEventListener('touchstart', function(e) {
                if (e.target.tagName !== 'INPUT' && e.target.tagName !== 'BUTTON') {
                    e.preventDefault();
                }
            }, { passive: false });
            
            document.addEventListener('touchmove', function(e) {
                if (e.target.tagName !== 'INPUT') {
                    e.preventDefault();
                }
            }, { passive: false });
            
            // Add touch feedback for volume slider
            const volumeSlider = document.getElementById('volume-slider');
            if (volumeSlider) {
                volumeSlider.addEventListener('touchstart', function() {
                    this.style.transform = 'scale(1.1)';
                    this.style.transition = 'transform 0.1s ease';
                });
                
                volumeSlider.addEventListener('touchend', function() {
                    this.style.transform = 'scale(1)';
                });
            }
            
            // Add double-tap to toggle audio
            let lastTap = 0;
            document.addEventListener('touchend', function(e) {
                const currentTime = new Date().getTime();
                const tapLength = currentTime - lastTap;
                
                if (tapLength < 500 && tapLength > 0) {
                    // Double tap detected
                    if (beatMachine && beatMachine.audioEngine) {
                        beatMachine.toggleAudio();
                    }
                }
                lastTap = currentTime;
            });
            
            // Optimize for mobile performance
            if (beatMachine && beatMachine.markovChain) {
                if (beatMachine.isMobile) {
                    // Reduce evolution frequency on mobile (but still faster than before)
                    beatMachine.markovChain.evolutionInterval = 8000; // 8 seconds instead of 5
                } else {
                    // Desktop gets even faster evolution for maximum visual impact
                    beatMachine.markovChain.evolutionInterval = 4000; // 4 seconds for desktop
                    console.log('🖥️ Desktop mode: Enhanced evolution every 4 seconds');
                }
            }
            
            console.log('Mobile interactions setup complete');
        }

        // ============================================================================
        // Initialize the Beat Generation Machine
        // ============================================================================
        let beatMachine;
        
        document.addEventListener('DOMContentLoaded', async () => {
            console.log('🎵 Beat Generation Interactive Poetry Machine - Web Edition');
            console.log('🎨 Memory-driven autonomous system');
            console.log('⚡ Waiting for user activation');
            
            try {
                // Initialize the machine (without audio)
                beatMachine = new BeatGenerationMachine();
                
                // Setup volume slider
                setupVolumeControl();
                
                // Setup mobile-specific interactions
                if (beatMachine.isMobile || beatMachine.isTouch) {
                    setupMobileInteractions();
                }
                
                // Desktop-specific enhancements (after beatMachine is initialized)
                if (!beatMachine.isMobile && beatMachine.markovChain) {
                    console.log('🖥️ Desktop mode: Maximum evolution frequency and visual effects enabled');
                    
                    // Add desktop-specific evolution logging
                    const originalEvolveNetwork = beatMachine.markovChain.evolveNetwork;
                    beatMachine.markovChain.evolveNetwork = function() {
                        console.log('🖥️ Desktop evolution triggered');
                        return originalEvolveNetwork.call(this);
                    };
                }
                
                // Setup audio activation button
                const audioPrompt = document.getElementById('audio-prompt');
                const startButton = document.getElementById('start-audio');
                
                startButton.addEventListener('click', async () => {
                    try {
                        console.log('🎵 User activated audio system');
                        
                        // Hide the prompt
                        audioPrompt.style.display = 'none';
                        
                        // Resume audio context with user gesture
                        if (beatMachine.audioContext.state === 'suspended') {
                            await beatMachine.audioContext.resume();
                            console.log('🎵 Audio context resumed');
                        }
                        
                        // Start the audio engine
                        if (beatMachine.audioEngine) {
                            beatMachine.audioEngine.start();
                            console.log('🎵 Memory-driven audio system activated');
                        }
                        
                        // Update poetry text
                        beatMachine.updatePoetryText('MEMORY SYSTEM ACTIVE');
                        
                    } catch (error) {
                        console.error('Audio activation failed:', error);
                        beatMachine.updatePoetryText('Audio activation failed');
                    }
                });
                
            } catch (error) {
                console.error('System initialization failed:', error);
                document.body.innerHTML = `
                    <div style="position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; color: #ff4444;">
                        <h1>System Initialization Failed</h1>
                        <p>Error: ${error.message}</p>
                        <button onclick="location.reload()" style="padding: 15px 30px; font-size: 1em; background: #ff4444; color: white; border: none; border-radius: 5px; cursor: pointer;">Reload Page</button>
                    </div>
                `;
            }
        });
    </script>
</body>
</html>
